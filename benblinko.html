<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>üöÄ BenBlinko ‚Ä¢ 4K Neon Laser Deluxe üöÄ</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="BenBlinko 4K">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      height: 100vh;
      overflow: hidden;
      font-family: 'Exo 2', 'Arial', sans-serif;
      background: #0a0a1a;
      color: #fff;
    }
    
    body {
      background: 
        linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%),
        radial-gradient(ellipse at top, #00d4ff33 0%, #ff006e22 70%, #000000 100%);
      background-attachment: fixed;
      animation: backgroundPulse 8s ease-in-out infinite alternate;
    }
    
    @keyframes backgroundPulse {
      0% { filter: hue-rotate(0deg) brightness(1); }
      100% { filter: hue-rotate(30deg) brightness(1.1); }
    }
    
    /* Intro Screen */
    .intro-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(10, 10, 26, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.5s ease-out;
    }
    
    .intro-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .laser-effects {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }
    
    .laser-beam {
      position: absolute;
      height: 3px;
      width: 200vw;
      background: linear-gradient(90deg, 
        transparent 0%, 
        #00d4ff 20%, 
        #ff006e 50%, 
        #00ff88 80%, 
        transparent 100%);
      filter: blur(2px);
      opacity: 0.6;
      animation: laserMove 4s linear infinite;
    }
    
    .laser-beam:nth-child(1) { top: 20%; transform: rotate(-5deg); animation-delay: 0s; }
    .laser-beam:nth-child(2) { top: 40%; transform: rotate(3deg); animation-delay: 1.5s; }
    .laser-beam:nth-child(3) { top: 60%; transform: rotate(-2deg); animation-delay: 3s; }
    .laser-beam:nth-child(4) { top: 80%; transform: rotate(4deg); animation-delay: 0.7s; }
    
    @keyframes laserMove {
      0% { left: -100vw; }
      100% { left: 0vw; }
    }
    
    .game-logo {
      width: clamp(200px, 40vw, 500px);
      height: auto;
      margin-bottom: 30px;
      filter: drop-shadow(0 0 30px #00d4ff) drop-shadow(0 0 60px #ff006e);
      animation: logoFloat 3s ease-in-out infinite alternate;
      cursor: pointer;
      transition: transform 0.3s ease;
    }
    
    .game-logo:hover {
      transform: scale(1.05);
    }
    
    @keyframes logoFloat {
      0% { transform: translateY(0px) scale(1); }
      100% { transform: translateY(-10px) scale(1.02); }
    }
    
    .start-text {
      font-family: 'Orbitron', monospace;
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      font-weight: 700;
      background: linear-gradient(45deg, #00d4ff, #ff006e, #00ff88);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-align: center;
      animation: textGlow 2s ease-in-out infinite alternate;
      cursor: pointer;
      margin: 20px;
      letter-spacing: 2px;
    }
    
    @keyframes textGlow {
      0% { filter: drop-shadow(0 0 10px #00d4ff88); }
      100% { filter: drop-shadow(0 0 20px #ff006e88); }
    }
    
    .credits {
      position: absolute;
      bottom: 30px;
      font-size: 1.2rem;
      color: #888;
      letter-spacing: 1px;
    }
    
    .help-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: linear-gradient(45deg, #00d4ff, #ff006e);
      border: none;
      padding: 12px 24px;
      border-radius: 25px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s ease;
    }
    
    .help-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px #00d4ff88;
    }
    
    /* Game Area */
    .game-container {
      display: none;
      width: 100vw;
      height: 100vh;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .game-container.active {
      display: flex;
    }
    
    .game-canvas {
      border: 4px solid #00d4ff;
      border-radius: 15px;
      background: linear-gradient(135deg, #1a1a3a 0%, #2d2d5a 100%);
      box-shadow: 
        0 0 30px #00d4ff66,
        inset 0 0 30px #ffffff11;
      margin-bottom: 20px;
      cursor: crosshair;
    }
    
    .game-ui {
      display: flex;
      justify-content: space-around;
      align-items: center;
      width: 90%;
      max-width: 800px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid #ffffff22;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
    }
    
    .score-item {
      text-align: center;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
    }
    
    .score-label {
      font-size: 0.9rem;
      color: #aaa;
      margin-bottom: 5px;
    }
    
    .score-value {
      font-size: 1.4rem;
      color: #00d4ff;
      text-shadow: 0 0 10px #00d4ff88;
    }
    
    .multiplier {
      background: linear-gradient(45deg, #ff006e, #00ff88);
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      animation: multiplierPulse 1s ease-in-out infinite alternate;
    }
    
    @keyframes multiplierPulse {
      0% { box-shadow: 0 0 10px #ff006e66; }
      100% { box-shadow: 0 0 20px #00ff8866; }
    }
    
    /* Game Over Screen */
    .game-over {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(10, 10, 26, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }
    
    .game-over.show {
      display: flex;
    }
    
    .game-over-title {
      font-family: 'Orbitron', monospace;
      font-size: clamp(2rem, 6vw, 4rem);
      font-weight: 900;
      background: linear-gradient(45deg, #ff006e, #00d4ff);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 30px;
      animation: titleGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes titleGlow {
      0% { filter: drop-shadow(0 0 20px #ff006e88); }
      100% { filter: drop-shadow(0 0 30px #00d4ff88); }
    }
    
    .final-score {
      font-size: 1.5rem;
      margin-bottom: 30px;
      text-align: center;
      line-height: 1.6;
    }
    
    .play-again-btn {
      background: linear-gradient(45deg, #00d4ff, #ff006e);
      border: none;
      padding: 15px 40px;
      border-radius: 30px;
      color: white;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Orbitron', monospace;
    }
    
    .play-again-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px #00d4ff88;
    }
    
    /* 4K Enhancements */
    @media (min-width: 2560px) {
      .game-canvas {
        border-width: 6px;
        box-shadow: 
          0 0 50px #00d4ff88,
          inset 0 0 50px #ffffff15;
      }
      
      .game-logo {
        filter: drop-shadow(0 0 50px #00d4ff) drop-shadow(0 0 100px #ff006e);
      }
      
      .laser-beam {
        height: 5px;
        filter: blur(3px);
      }
    }
    
    /* iPhone 16 Pro & Mobile optimizations */
    @media (max-width: 430px) {
      /* iPhone 16 Pro specific (430x932px) */
      .game-canvas {
        width: 90vw;
        height: 55vh;
        max-width: 400px;
        max-height: 500px;
      }
      
      .game-ui {
        width: 95%;
        padding: 10px;
        margin-bottom: env(safe-area-inset-bottom, 20px);
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
      }
      
      .start-text {
        font-size: clamp(1.8rem, 6vw, 2.2rem);
        margin: 15px;
      }
      
      .game-logo {
        width: clamp(180px, 45vw, 300px);
        margin-bottom: 20px;
      }
      
      .help-btn {
        top: env(safe-area-inset-top, 15px);
        right: 15px;
        padding: 8px 16px;
        font-size: 0.9rem;
      }
      
      .credits {
        bottom: env(safe-area-inset-bottom, 30px);
      }
    }
    
    @media (max-width: 768px) {
      .game-ui {
        flex-wrap: wrap;
        gap: 8px;
        padding: 12px;
      }
      
      .score-item {
        flex: 1;
        min-width: 70px;
      }
      
      .score-value {
        font-size: 1.2rem;
      }
      
      .score-label {
        font-size: 0.8rem;
      }
    }
    
    /* Landscape mobile */
    @media (max-height: 500px) and (orientation: landscape) {
      .intro-screen {
        flex-direction: row;
        gap: 20px;
        padding: 20px;
      }
      
      .game-logo {
        width: clamp(120px, 25vw, 200px);
        margin: 0;
      }
      
      .start-text {
        font-size: clamp(1.2rem, 4vw, 1.8rem);
        margin: 10px;
      }
      
      .game-canvas {
        height: 70vh;
        max-height: 300px;
      }
    }
  </style>
</head>
<body>
  <!-- Intro Screen -->
  <div class="intro-screen" id="introScreen">
    <div class="laser-effects">
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
    </div>
    
    <img src="img/logo.png" alt="BenBlinko Logo" class="game-logo" id="gameLogo">
    <div class="start-text" id="startText">üöÄ CLICK TO START üöÄ</div>
    <div class="credits">by BensBar</div>
    <button class="help-btn" id="helpBtn">‚ùì Help</button>
  </div>
  
  <!-- Game Container -->
  <div class="game-container" id="gameContainer">
    <canvas class="game-canvas" id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="game-ui">
      <div class="score-item">
        <div class="score-label">SCORE</div>
        <div class="score-value" id="scoreValue">0</div>
      </div>
      
      <div class="score-item">
        <div class="score-label">HIGH SCORE</div>
        <div class="score-value" id="highScoreValue">0</div>
      </div>
      
      <div class="score-item">
        <div class="score-label">BALLS LEFT</div>
        <div class="score-value" id="ballsValue">5</div>
      </div>
      
      <div class="score-item">
        <div class="score-label">MULTIPLIER</div>
        <div class="score-value multiplier" id="multiplierValue">x1</div>
      </div>
    </div>
  </div>
  
  <!-- Game Over Screen -->
  <div class="game-over" id="gameOverScreen">
    <div class="laser-effects">
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
    </div>
    
    <div class="game-over-title">GAME OVER</div>
    <div class="final-score" id="finalScore"></div>
    <button class="play-again-btn" id="playAgainBtn">üéÆ PLAY AGAIN üéÆ</button>
  </div>

  <script>
    // üöÄ BENBLINKO 4K NEON LASER DELUXE üöÄ
    console.log("üöÄ BenBlinko 4K Neon Laser Deluxe Loading...");
    
    // Game Elements
    const introScreen = document.getElementById('introScreen');
    const gameContainer = document.getElementById('gameContainer');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startText = document.getElementById('startText');
    const gameLogo = document.getElementById('gameLogo');
    const helpBtn = document.getElementById('helpBtn');
    const playAgainBtn = document.getElementById('playAgainBtn');
    
    // UI Elements
    const scoreValue = document.getElementById('scoreValue');
    const highScoreValue = document.getElementById('highScoreValue');
    const ballsValue = document.getElementById('ballsValue');
    const multiplierValue = document.getElementById('multiplierValue');
    const finalScore = document.getElementById('finalScore');
    
    // Game State
    let gameState = 'intro'; // intro, playing, gameOver
    let score = 0;
    let highScore = 0;
    let ballsLeft = 5;
    let multiplier = 1;
    let balls = [];
    let pegs = [];
    let particles = [];
    let slots = [];
    
    // Game Constants
    const GRAVITY = 0.3;
    const BOUNCE = 0.8;
    const PEG_RADIUS = 8;
    const BALL_RADIUS = 12;
    const SLOT_VALUES = [100, 500, 1000, 5000, 10000, 5000, 1000, 500, 100];
    const SLOT_COLORS = ['#ff006e', '#00d4ff', '#00ff88', '#ffff00', '#ff6600', '#ffff00', '#00ff88', '#00d4ff', '#ff006e'];
    
    // Load high score
    try {
      const saved = localStorage.getItem('benblinko_highscore');
      if (saved) highScore = parseInt(saved);
    } catch (e) {
      console.log('Could not load high score');
    }
    
    // Initialize Canvas
    function initCanvas() {
      // Set canvas size directly
      canvas.width = 800;
      canvas.height = 600;
      
      // High quality rendering
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      createPegs();
      createSlots();
    }
    
    // Create Pegs
    function createPegs() {
      pegs = [];
      const rows = 12;
      const pegsPerRow = 7;
      const pegSpacing = 80;
      const rowSpacing = 40;
      const startY = 100;
      
      for (let row = 0; row < rows; row++) {
        // Stagger every other row by offsetting odd rows
        const isOddRow = row % 2 === 1;
        const pegCount = pegsPerRow;
        const offsetX = isOddRow ? pegSpacing / 2 : 0;
        const startX = (canvas.width - (pegCount - 1) * pegSpacing) / 2 + offsetX;
        
        for (let col = 0; col < pegCount; col++) {
          pegs.push({
            x: startX + col * pegSpacing,
            y: startY + row * rowSpacing,
            radius: PEG_RADIUS,
            hit: false,
            special: Math.random() < 0.1, // 10% chance for special pegs that grant extra balls
            glowPhase: Math.random() * Math.PI * 2
          });
        }
      }
      
      console.log(`Created ${pegs.length} pegs with proper alternating stagger pattern`);
    }
    
    // Create Slots
    function createSlots() {
      slots = [];
      const slotWidth = canvas.width / SLOT_VALUES.length;
      
      for (let i = 0; i < SLOT_VALUES.length; i++) {
        slots.push({
          x: i * slotWidth,
          y: canvas.height - 120,  // Raised from -60 to -120
          width: slotWidth,
          height: 50,
          value: SLOT_VALUES[i],
          color: SLOT_COLORS[i]
        });
      }
      
      console.log(`Created ${slots.length} slots`);
    }
    
    // Ball Class
    class Ball {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = 0;
        this.radius = BALL_RADIUS;
        this.color = '#00d4ff';
        this.trail = [];
        this.glowPhase = 0;
      }
      
      update() {
        // Apply tilt if enabled (moved to handleDeviceOrientation for better responsiveness)
        
        // Physics
        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;
        
        // Air resistance to prevent excessive speed
        this.vx *= 0.995;
        this.vy *= 0.999;
        
        // Trail effect
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 10) this.trail.shift();
        
        this.glowPhase += 0.1;
        
        // Wall bouncing
        if (this.x - this.radius < 0) {
          this.x = this.radius;
          this.vx = Math.abs(this.vx) * BOUNCE;
        }
        if (this.x + this.radius > canvas.width) {
          this.x = canvas.width - this.radius;
          this.vx = -Math.abs(this.vx) * BOUNCE;
        }
        
        // Peg collision - allow multiple bounces per frame for realistic physics
        let collisionCount = 0;
        for (let i = 0; i < pegs.length && collisionCount < 3; i++) {
          const peg = pegs[i];
          const dx = this.x - peg.x;
          const dy = this.y - peg.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.radius + peg.radius) {
            collisionCount++;
            
            // Score only once per peg
            if (!peg.hit) {
              peg.hit = true;
              
              let points = peg.special ? 500 : 100;
              points *= multiplier;
              score += points;
              
              if (peg.special) {
                multiplier++;
                ballsLeft++; // Grant extra ball for special pegs!
                createParticles(peg.x, peg.y, '#00ff88', 30);
                console.log(`Special peg hit! Granted extra ball. Balls left: ${ballsLeft}`);
              } else {
                createParticles(peg.x, peg.y, '#00d4ff', 10);
              }
              
              updateUI();
            }
            
            // Physics collision response
            const overlap = this.radius + peg.radius - distance;
            if (distance > 0 && overlap > 0) {
              // Normalize and separate
              const nx = dx / distance;
              const ny = dy / distance;
              
              // Move ball out of peg
              this.x += nx * overlap;
              this.y += ny * overlap;
              
              // Reflect velocity with realistic physics
              const dot = this.vx * nx + this.vy * ny;
              this.vx -= 2 * dot * nx;
              this.vy -= 2 * dot * ny;
              
              // Add some random bounce for realistic Plinko effect
              this.vx += (Math.random() - 0.5) * 1.5;
              this.vy += (Math.random() - 0.5) * 0.5;
              
              // Apply bounce factor
              this.vx *= BOUNCE;
              this.vy *= BOUNCE;
            }
          }
        }
        
        // Slot collision
        if (this.y + this.radius >= canvas.height - 120) {  // Updated to match new slot position
          if (!this.toRemove) {  // Only process if not already marked for removal
            const slotWidth = canvas.width / SLOT_VALUES.length;
            const slotIndex = Math.floor(this.x / slotWidth);
            if (slotIndex >= 0 && slotIndex < slots.length) {
              const slot = slots[slotIndex];
              score += slot.value * multiplier;
              createParticles(this.x, this.y, slot.color, 30);
            }
            
            // Mark for removal
            this.toRemove = true;
            ballsLeft--;
            multiplier = 1;
            updateUI();
            
            if (ballsLeft <= 0) {
              setTimeout(() => endGame(), 500);
            }
          }
        }
        
        // Remove balls that fall off screen
        if (this.y > canvas.height + 100) {
          if (!this.toRemove) {  // Only process if not already marked for removal
            this.toRemove = true;
            ballsLeft--;
            updateUI();
            
            if (ballsLeft <= 0) {
              setTimeout(() => endGame(), 500);
            }
          }
        }
      }
      
      draw() {
        ctx.save();
        
        // Draw trail
        for (let i = 0; i < this.trail.length; i++) {
          const alpha = i / this.trail.length * 0.3;
          const point = this.trail[i];
          ctx.globalAlpha = alpha;
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(point.x, point.y, this.radius * (i / this.trail.length), 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.globalAlpha = 1;
        
        // Draw main ball with glow
        const glow = Math.sin(this.glowPhase) * 0.3 + 0.7;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 20 * glow;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
    }
    
    // Particle Class
    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.color = color;
        this.life = 1;
        this.decay = Math.random() * 0.02 + 0.01;
        this.size = Math.random() * 4 + 2;
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1; // gravity
        this.life -= this.decay;
        this.vx *= 0.99; // air resistance
      }
      
      draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    // Create Particles
    function createParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color));
      }
    }
    
    // Update UI
    function updateUI() {
      scoreValue.textContent = score.toLocaleString();
      highScoreValue.textContent = highScore.toLocaleString();
      ballsValue.textContent = ballsLeft;
      multiplierValue.textContent = `x${multiplier}`;
    }
    
    // Drop Ball
    function dropBall(x) {
      // Only allow one ball at a time
      if (ballsLeft > 0 && gameState === 'playing' && balls.length === 0) {
        console.log(`Dropping ball at position ${x}, balls left: ${ballsLeft}`);
        balls.push(new Ball(x, 50));
      } else if (balls.length > 0) {
        console.log(`Cannot drop ball: another ball is still active (${balls.length} balls active)`);
      } else {
        console.log(`Cannot drop ball: ballsLeft=${ballsLeft}, gameState=${gameState}`);
      }
    }
    
    // Start Game
    function startGame() {
      console.log("üéÆ Starting BenBlinko!");
      
      gameState = 'playing';
      score = 0;
      ballsLeft = 5;
      multiplier = 1;
      balls = [];
      particles = [];
      
      // Reset pegs
      pegs.forEach(peg => {
        peg.hit = false;
      });
      
      introScreen.classList.add('hidden');
      gameContainer.classList.add('active');
      gameOverScreen.classList.remove('show');
      
      updateUI();
      
      console.log(`Game started with ${pegs.length} pegs and ${slots.length} slots`);
      
      // Auto-drop first ball after a short delay
      setTimeout(() => {
        console.log("Auto-dropping first ball");
        dropBall(canvas.width / 2);
      }, 1000);
    }
    
    // End Game
    function endGame() {
      gameState = 'gameOver';
      
      if (score > highScore) {
        highScore = score;
        try {
          localStorage.setItem('benblinko_highscore', highScore.toString());
        } catch (e) {}
      }
      
      finalScore.innerHTML = `
        <div>Final Score: <strong>${score.toLocaleString()}</strong></div>
        <div>High Score: <strong>${highScore.toLocaleString()}</strong></div>
      `;
      
      setTimeout(() => {
        gameOverScreen.classList.add('show');
      }, 1000);
    }
    
    // Reset Game
    function resetGame() {
      gameState = 'intro';
      gameContainer.classList.remove('active');
      gameOverScreen.classList.remove('show');
      introScreen.classList.remove('hidden');
      
      balls = [];
      particles = [];
      
      // Reset pegs
      pegs.forEach(peg => {
        peg.hit = false;
      });
    }
    
    // Draw Game
    function draw() {
      // Clear canvas with gradient background
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#1a1a3a');
      gradient.addColorStop(1, '#0a0a1a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      if (gameState !== 'playing') return;
      
      // Draw slots
      slots.forEach((slot, index) => {
        ctx.fillStyle = slot.color + '66';
        ctx.fillRect(slot.x, slot.y, slot.width, slot.height);
        
        ctx.fillStyle = slot.color;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(slot.x, slot.y, slot.width, slot.height);
        
        // Draw slot value
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 14px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText(slot.value.toLocaleString(), slot.x + slot.width / 2, slot.y + slot.height / 2 + 6);
      });
      
      // Draw bottom collection area
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, canvas.height - 70, canvas.width, 70);
      ctx.strokeStyle = '#00d4ff';
      ctx.lineWidth = 2;
      ctx.strokeRect(0, canvas.height - 70, canvas.width, 70);
      
      // Draw pegs
      pegs.forEach((peg, index) => {
        ctx.save();
        
        if (peg.hit) {
          ctx.globalAlpha = 0.3;
        }
        
        const glow = Math.sin(peg.glowPhase + Date.now() * 0.01) * 0.3 + 0.7;
        
        if (peg.special) {
          ctx.shadowColor = '#00ff88';
          ctx.shadowBlur = 15 * glow;
          ctx.fillStyle = '#00ff88';
        } else {
          ctx.shadowColor = '#00d4ff';
          ctx.shadowBlur = 10 * glow;
          ctx.fillStyle = '#00d4ff';
        }
        
        ctx.beginPath();
        ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      });
      
      // Draw balls
      balls.forEach((ball, index) => {
        ball.draw();
      });
      
      // Draw particles
      particles = particles.filter(particle => {
        particle.update();
        particle.draw();
        return particle.life > 0;
      });
      
      // Debug info
      if (gameState === 'playing') {
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Pegs: ${pegs.length}`, 10, 20);
        ctx.fillText(`Balls: ${balls.length}`, 10, 35);
        ctx.fillText(`Particles: ${particles.length}`, 10, 50);
      }
    }
    
    // Game Loop
    function gameLoop() {
      try {
        if (gameState === 'playing') {
          // Update balls
          balls.forEach(ball => {
            if (!ball.toRemove) {
              ball.update();
            }
          });
          
          // Remove balls marked for removal
          const initialBallCount = balls.length;
          balls = balls.filter(ball => !ball.toRemove);
          
          // Debug logging for ball removal
          if (initialBallCount !== balls.length) {
            console.log(`Removed ${initialBallCount - balls.length} balls, ${balls.length} remaining, ${ballsLeft} balls left`);
          }
        }
        
        draw();
      } catch (error) {
        console.error('Game loop error:', error);
      }
      
      requestAnimationFrame(gameLoop);
    }
    
    // Event Listeners
    startText.addEventListener('click', startGame);
    gameLogo.addEventListener('click', startGame);
    
    canvas.addEventListener('click', (e) => {
      if (gameState === 'playing') {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        console.log(`Dropping ball at x: ${x}`);
        dropBall(x);
      }
    });
    
    playAgainBtn.addEventListener('click', resetGame);
    
    helpBtn.addEventListener('click', () => {
      alert(`üöÄ BenBlinko 4K Neon Laser Deluxe üöÄ

üéØ HOW TO PLAY:
‚Ä¢ Click anywhere to drop a ball (one at a time)
‚Ä¢ Hit pegs to score points
‚Ä¢ Green special pegs give bonus points, increase multiplier AND grant an extra ball!
‚Ä¢ Balls land in slots at the bottom for bonus scores
‚Ä¢ Try to get the highest score possible!

üéÆ CONTROLS:
‚Ä¢ Click the logo or "CLICK TO START" to begin
‚Ä¢ Click anywhere on the game area to drop balls
‚Ä¢ Use your mouse to aim where the ball drops
‚Ä¢ Only one ball drops at a time for strategic gameplay

üèÜ SCORING:
‚Ä¢ Regular pegs: 100 points √ó multiplier
‚Ä¢ Special green pegs: 500 points √ó multiplier + extra ball + multiplier boost!
‚Ä¢ Slot bonuses: Various point values √ó multiplier

üéÅ BONUS:
‚Ä¢ Hit green special pegs to earn extra balls and extend your game!

Good luck and have fun! üéâ`);
    });
    
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (gameState === 'intro') {
          startGame();
        } else if (gameState === 'playing') {
          dropBall(canvas.width / 2);
        } else if (gameState === 'gameOver') {
          resetGame();
        }
      }
    });
    
    // Mobile Device Orientation & Accelerometer Support
    let tiltEnabled = false;
    let tilt = 0;
    let lastGamma = 0;
    const TILT_SENSITIVITY = 3.5; // Optimized for responsive control
    
    function handleDeviceOrientation(event) {
      if (!tiltEnabled || gameState !== 'playing') return;
      
      // Get the device orientation data
      let gamma = event.gamma || 0; // Left/right tilt (-90 to 90)
      let beta = event.beta || 0;   // Front/back tilt (-180 to 180)
      let alpha = event.alpha || 0; // Compass direction (0-360)
      
      // Account for different device orientations
      let orientation = window.screen && window.screen.orientation ? 
                       window.screen.orientation.angle : 
                       (window.orientation || 0);
      
      // Correct tilt values based on device orientation
      let adjustedTilt = gamma;
      switch (orientation) {
        case 90: // Landscape left (rotated counter-clockwise)
          adjustedTilt = beta;
          break;
        case -90: // Landscape right (rotated clockwise)
        case 270: // Landscape right (270 degrees)
          adjustedTilt = -beta;
          break;
        case 180: // Portrait upside down
          adjustedTilt = -gamma;
          break;
        default: // Portrait (0 degrees)
          adjustedTilt = gamma;
          break;
      }
      
      // Apply sensitivity and bounds - increased sensitivity for better responsiveness
      const rawTilt = adjustedTilt * TILT_SENSITIVITY / 15; // Increased sensitivity
      const targetTilt = Math.max(-8, Math.min(8, rawTilt)); // Wider range
      
      // Smooth interpolation with quicker response
      tilt = tilt * 0.6 + targetTilt * 0.4;
      
      // Apply tilt force directly to active balls with enhanced effect
      balls.forEach(ball => {
        if (!ball.toRemove) {
          // Apply horizontal force based on tilt
          const tiltForce = tilt * 0.05; // Increased force multiplier
          ball.vx += tiltForce;
          
          // Prevent excessive horizontal velocity
          ball.vx = Math.max(-12, Math.min(12, ball.vx));
        }
      });
    }
    
    function requestMotionPermission() {
      // Show tilt enable button on mobile devices
      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        const tiltBtn = document.createElement('button');
        tiltBtn.innerHTML = 'üì± Enable Tilt Control';
        tiltBtn.style.cssText = `
          position: absolute;
          bottom: 80px;
          left: 50%;
          transform: translateX(-50%);
          background: linear-gradient(45deg, #00d4ff, #ff006e);
          border: none;
          padding: 12px 24px;
          border-radius: 25px;
          color: white;
          font-weight: bold;
          cursor: pointer;
          font-size: 1rem;
          z-index: 1002;
          box-shadow: 0 0 20px #00d4ff88;
          transition: all 0.3s ease;
        `;
        
        // Add hover effect
        tiltBtn.addEventListener('mouseenter', () => {
          tiltBtn.style.transform = 'translateX(-50%) scale(1.05)';
        });
        
        tiltBtn.addEventListener('mouseleave', () => {
          tiltBtn.style.transform = 'translateX(-50%) scale(1)';
        });
        
        tiltBtn.addEventListener('click', async () => {
          try {
            // Disable button during request
            tiltBtn.disabled = true;
            tiltBtn.innerHTML = 'üîÑ Requesting Permission...';
            
            // Check for iOS 13+ permission system
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
              
              console.log('Requesting iOS motion permission...');
              const permission = await DeviceOrientationEvent.requestPermission();
              
              if (permission === 'granted') {
                console.log('iOS motion permission granted');
                enableTiltControl();
                tiltBtn.remove();
              } else {
                console.log('iOS motion permission denied:', permission);
                tiltBtn.innerHTML = '‚ùå Permission Denied';
                tiltBtn.style.background = 'linear-gradient(45deg, #ff4444, #cc0000)';
                
                setTimeout(() => {
                  tiltBtn.innerHTML = 'üì± Enable Tilt Control';
                  tiltBtn.style.background = 'linear-gradient(45deg, #00d4ff, #ff006e)';
                  tiltBtn.disabled = false;
                }, 2000);
                
                // Show helpful message
                const helpMsg = document.createElement('div');
                helpMsg.innerHTML = `
                  <div style="position: fixed; bottom: 140px; left: 50%; transform: translateX(-50%); 
                              background: rgba(255,68,68,0.9); padding: 12px 20px; border-radius: 15px; 
                              color: white; font-size: 0.9rem; z-index: 1004; text-align: center; max-width: 280px;">
                    To enable tilt control:<br>
                    1. Go to Safari Settings<br>
                    2. Enable Motion & Orientation Access<br>
                    3. Refresh this page
                  </div>
                `;
                document.body.appendChild(helpMsg);
                
                setTimeout(() => {
                  if (helpMsg.parentNode) {
                    helpMsg.remove();
                  }
                }, 5000);
              }
            } else {
              // Android devices or older browsers - test if orientation events work
              console.log('Non-iOS device or older browser, testing orientation support...');
              
              // Test if we can receive orientation events
              let testTimeout = setTimeout(() => {
                console.log('Orientation events not supported or blocked');
                tiltBtn.innerHTML = '‚ùå Not Supported';
                tiltBtn.style.background = 'linear-gradient(45deg, #ff4444, #cc0000)';
                setTimeout(() => {
                  tiltBtn.remove();
                }, 2000);
              }, 2000);
              
              const testOrientation = (event) => {
                clearTimeout(testTimeout);
                window.removeEventListener('deviceorientation', testOrientation);
                console.log('Orientation events working on non-iOS device');
                enableTiltControl();
                tiltBtn.remove();
              };
              
              window.addEventListener('deviceorientation', testOrientation, { once: true });
            }
          } catch (error) {
            console.error('Motion permission error:', error);
            
            // Try to enable anyway for older devices/browsers
            tiltBtn.innerHTML = 'üîÑ Enabling...';
            
            setTimeout(() => {
              try {
                enableTiltControl();
                tiltBtn.remove();
              } catch (fallbackError) {
                console.error('Fallback enable failed:', fallbackError);
                tiltBtn.innerHTML = '‚ùå Failed';
                tiltBtn.style.background = 'linear-gradient(45deg, #ff4444, #cc0000)';
                setTimeout(() => tiltBtn.remove(), 2000);
              }
            }, 1000);
          }
        });
        
        document.getElementById('introScreen').appendChild(tiltBtn);
      }
    }
    
    function enableTiltControl() {
      tiltEnabled = true;
      
      // Add event listeners for device orientation with better browser support
      if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', handleDeviceOrientation, { passive: false });
        
        // Some browsers support absolute orientation events (more stable)
        if ('ondeviceorientationabsolute' in window) {
          window.addEventListener('deviceorientationabsolute', handleDeviceOrientation, { passive: false });
        }
      }
      
      // Show tilt indicator with real-time feedback
      const tiltIndicator = document.createElement('div');
      tiltIndicator.id = 'tiltIndicator';
      tiltIndicator.innerHTML = `
        <div style="position: fixed; top: 10px; left: 10px; 
                    background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 10px; 
                    color: #00d4ff; font-size: 0.8rem; z-index: 1003; font-family: monospace;
                    border: 1px solid #00d4ff44; backdrop-filter: blur(5px);">
          üì± Tilt: <span id="tiltValue">0.0</span>¬∞ | Orient: <span id="orientValue">0</span>¬∞
        </div>
      `;
      document.body.appendChild(tiltIndicator);
      
      // Update tilt display with detailed info
      const updateTiltDisplay = () => {
        const tiltValueElement = document.getElementById('tiltValue');
        const orientValueElement = document.getElementById('orientValue');
        
        if (tiltValueElement && tiltEnabled) {
          tiltValueElement.textContent = tilt.toFixed(1);
        }
        
        if (orientValueElement) {
          const orientation = window.screen && window.screen.orientation ? 
                             window.screen.orientation.angle : 
                             (window.orientation || 0);
          orientValueElement.textContent = orientation;
        }
      };
      
      // Update display every 100ms
      const tiltDisplayInterval = setInterval(updateTiltDisplay, 100);
      
      // Store interval ID to clear it later if needed
      window.tiltDisplayInterval = tiltDisplayInterval;
      
      console.log('Tilt control enabled for mobile device');
      
      // Show success message with instructions
      const successMsg = document.createElement('div');
      successMsg.innerHTML = `
        <div style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); 
                    background: rgba(0,255,136,0.9); padding: 12px 20px; border-radius: 15px; 
                    color: white; font-size: 0.9rem; z-index: 1004; text-align: center;
                    box-shadow: 0 0 20px rgba(0,255,136,0.5); max-width: 300px;">
          ‚úÖ Tilt control enabled!<br>
          <small>Tilt your device left/right to guide the ball</small>
        </div>
      `;
      document.body.appendChild(successMsg);
      
      setTimeout(() => {
        if (successMsg.parentNode) {
          successMsg.remove();
        }
      }, 4000);
      
      // Test orientation immediately
      setTimeout(() => {
        console.log('Testing initial device orientation...');
        if (window.DeviceOrientationEvent) {
          // Dispatch a test event to see if the handler works
          console.log('Device orientation support confirmed');
        }
      }, 500);
    }
    
    // Disable tilt control (for cleanup)
    function disableTiltControl() {
      tiltEnabled = false;
      tilt = 0;
      
      // Remove event listeners
      window.removeEventListener('deviceorientation', handleDeviceOrientation);
      window.removeEventListener('deviceorientationabsolute', handleDeviceOrientation);
      
      // Clear display update interval
      if (window.tiltDisplayInterval) {
        clearInterval(window.tiltDisplayInterval);
        window.tiltDisplayInterval = null;
      }
      
      // Remove tilt indicator
      const tiltIndicator = document.getElementById('tiltIndicator');
      if (tiltIndicator) {
        tiltIndicator.remove();
      }
      
      console.log('Tilt control disabled');
    }
    
    // Touch controls for mobile with improved responsiveness
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchStartTime = Date.now();
    }, { passive: false });
    
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      
      if (gameState === 'playing') {
        const touchDuration = Date.now() - touchStartTime;
        
        // Only register as tap if touch was brief (< 300ms) and didn't move much
        if (touchDuration < 300) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const x = (touchStartX - rect.left) * scaleX;
          
          // Ensure ball is dropped within canvas bounds
          const clampedX = Math.max(BALL_RADIUS, Math.min(canvas.width - BALL_RADIUS, x));
          console.log(`Touch drop at x: ${clampedX} (original: ${x})`);
          dropBall(clampedX);
        }
      }
    }, { passive: false });
    
    // Prevent scrolling on the canvas
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });
    
    // Initialize motion controls
    window.addEventListener('load', () => {
      setTimeout(requestMotionPermission, 1000);
    });
    
    // Initialize
    window.addEventListener('load', () => {
      console.log("üöÄ BenBlinko 4K Neon Laser Deluxe Loaded!");
      initCanvas();
      updateUI();
      gameLoop();
    });
    
    window.addEventListener('resize', initCanvas);
    
    console.log("üöÄ BenBlinko 4K Neon Laser Deluxe Ready!");
  </script>
</body>
</html>
