<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>🚀 BenBlinko • 4K Neon Laser Deluxe 🚀</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="BenBlinko 4K">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      height: 100vh;
      overflow: hidden;
      font-family: 'Exo 2', 'Arial', sans-serif;
      background: #0a0a1a;
      color: #fff;
    }
    
    body {
      background: 
        linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%),
        radial-gradient(ellipse at top, #00d4ff33 0%, #ff006e22 70%, #000000 100%);
      background-attachment: fixed;
      animation: backgroundPulse 8s ease-in-out infinite alternate;
    }
    
    @keyframes backgroundPulse {
      0% { filter: hue-rotate(0deg) brightness(1); }
      100% { filter: hue-rotate(30deg) brightness(1.1); }
    }
    
    /* Intro Screen */
    .intro-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(10, 10, 26, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.5s ease-out;
    }
    
    .intro-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .laser-effects {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }
    
    .laser-beam {
      position: absolute;
      height: 3px;
      width: 200vw;
      background: linear-gradient(90deg, 
        transparent 0%, 
        #00d4ff 20%, 
        #ff006e 50%, 
        #00ff88 80%, 
        transparent 100%);
      filter: blur(2px);
      opacity: 0.6;
      animation: laserMove 4s linear infinite;
    }
    
    .laser-beam:nth-child(1) { top: 20%; transform: rotate(-5deg); animation-delay: 0s; }
    .laser-beam:nth-child(2) { top: 40%; transform: rotate(3deg); animation-delay: 1.5s; }
    .laser-beam:nth-child(3) { top: 60%; transform: rotate(-2deg); animation-delay: 3s; }
    .laser-beam:nth-child(4) { top: 80%; transform: rotate(4deg); animation-delay: 0.7s; }
    
    @keyframes laserMove {
      0% { left: -100vw; }
      100% { left: 0vw; }
    }
    
    .game-logo {
      width: clamp(200px, 40vw, 500px);
      height: auto;
      margin-bottom: 30px;
      filter: drop-shadow(0 0 30px #00d4ff) drop-shadow(0 0 60px #ff006e);
      animation: logoFloat 3s ease-in-out infinite alternate;
      cursor: pointer;
      transition: transform 0.3s ease;
    }
    
    .game-logo:hover {
      transform: scale(1.05);
    }
    
    @keyframes logoFloat {
      0% { transform: translateY(0px) scale(1); }
      100% { transform: translateY(-10px) scale(1.02); }
    }
    
    .start-text {
      font-family: 'Orbitron', monospace;
      font-size: clamp(1.5rem, 4vw, 2.5rem);
      font-weight: 700;
      background: linear-gradient(45deg, #00d4ff, #ff006e, #00ff88);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-align: center;
      animation: textGlow 2s ease-in-out infinite alternate;
      cursor: pointer;
      margin: 20px;
      letter-spacing: 2px;
    }
    
    @keyframes textGlow {
      0% { filter: drop-shadow(0 0 10px #00d4ff88); }
      100% { filter: drop-shadow(0 0 20px #ff006e88); }
    }
    
    .credits {
      position: absolute;
      bottom: 30px;
      font-size: 1.2rem;
      color: #888;
      letter-spacing: 1px;
    }
    
    .help-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: linear-gradient(45deg, #00d4ff, #ff006e);
      border: none;
      padding: 12px 24px;
      border-radius: 25px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s ease;
    }
    
    .help-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px #00d4ff88;
    }

    /* Help Screen */
    .help-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(10, 10, 26, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      backdrop-filter: blur(10px);
      overflow-y: auto;
      padding: 20px;
    }
    
    .help-screen.visible {
      display: flex;
    }
    
    .help-content {
      background: linear-gradient(135deg, rgba(26, 26, 46, 0.9), rgba(22, 33, 62, 0.9));
      border: 2px solid #00d4ff;
      border-radius: 20px;
      padding: 30px;
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 0 50px rgba(0, 212, 255, 0.3);
      animation: helpSlideIn 0.5s ease-out;
    }
    
    @keyframes helpSlideIn {
      0% { opacity: 0; transform: scale(0.8) translateY(-50px); }
      100% { opacity: 1; transform: scale(1) translateY(0); }
    }
    
    .help-content h2 {
      color: #00d4ff;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.8rem;
      text-align: center;
      margin-bottom: 25px;
      text-shadow: 0 0 15px #00d4ff;
    }
    
    .help-section {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      border-left: 4px solid #ff006e;
    }
    
    .help-section h3 {
      color: #ff006e;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #ff006e;
    }
    
    .help-section p {
      color: #ffffff;
      margin: 5px 0;
      line-height: 1.5;
      font-size: 0.95rem;
    }
    
    .help-section p strong {
      color: #00ff88;
      text-shadow: 0 0 5px #00ff88;
    }
    
    .help-section p em {
      color: #ffff00;
      font-style: italic;
    }
    
    .close-help-btn {
      background: linear-gradient(45deg, #00ff88, #00d4ff);
      border: none;
      padding: 15px 30px;
      border-radius: 25px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.1rem;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
      display: block;
      margin: 20px auto 0;
      width: fit-content;
    }
    
    .close-help-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
    }
    
    /* Game Area */
    .game-container {
      display: none;
      width: 100vw;
      height: 100vh;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .game-container.active {
      display: flex;
    }
    
    .game-canvas {
      border: 4px solid #00d4ff;
      border-radius: 15px;
      background: linear-gradient(135deg, #1a1a3a 0%, #2d2d5a 100%);
      box-shadow: 
        0 0 30px #00d4ff66,
        inset 0 0 30px #ffffff11;
      margin-bottom: 20px;
      cursor: crosshair;
    }
    
    .game-ui {
      display: flex;
      justify-content: space-around;
      align-items: center;
      width: 90%;
      max-width: 800px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid #ffffff22;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
    }
    
    .score-item {
      text-align: center;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
    }
    
    .score-label {
      font-size: 0.9rem;
      color: #aaa;
      margin-bottom: 5px;
    }
    
    .score-value {
      font-size: 1.4rem;
      color: #00d4ff;
      text-shadow: 0 0 10px #00d4ff88;
    }
    
    .multiplier {
      background: linear-gradient(45deg, #ff006e, #00ff88);
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      animation: multiplierPulse 1s ease-in-out infinite alternate;
    }
    
    @keyframes multiplierPulse {
      0% { box-shadow: 0 0 10px #ff006e66; }
      100% { box-shadow: 0 0 20px #00ff8866; }
    }
    
    @keyframes powerUpPulse {
      0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
      50% { transform: translateX(-50%) scale(1.2); opacity: 1; }
      100% { transform: translateX(-50%) scale(1); opacity: 1; }
    }
    
    @keyframes comboGlow {
      0% { box-shadow: 0 0 20px #ff006e88; }
      100% { box-shadow: 0 0 40px #ffff0088; }
    }
    
    /* Game Over Screen */
    .game-over {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(10, 10, 26, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }
    
    .game-over.show {
      display: flex;
    }
    
    .game-over-title {
      font-family: 'Orbitron', monospace;
      font-size: clamp(2rem, 6vw, 4rem);
      font-weight: 900;
      background: linear-gradient(45deg, #ff006e, #00d4ff);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 30px;
      animation: titleGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes titleGlow {
      0% { filter: drop-shadow(0 0 20px #ff006e88); }
      100% { filter: drop-shadow(0 0 30px #00d4ff88); }
    }
    
    .final-score {
      font-size: 1.5rem;
      margin-bottom: 30px;
      text-align: center;
      line-height: 1.6;
    }
    
    .play-again-btn {
      background: linear-gradient(45deg, #00d4ff, #ff006e);
      border: none;
      padding: 15px 40px;
      border-radius: 30px;
      color: white;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Orbitron', monospace;
    }
    
    .play-again-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 30px #00d4ff88;
    }
    
    /* 4K Enhancements */
    @media (min-width: 2560px) {
      .game-canvas {
        border-width: 6px;
        box-shadow: 
          0 0 50px #00d4ff88,
          inset 0 0 50px #ffffff15;
      }
      
      .game-logo {
        filter: drop-shadow(0 0 50px #00d4ff) drop-shadow(0 0 100px #ff006e);
      }
      
      .laser-beam {
        height: 5px;
        filter: blur(3px);
      }
    }
    
    /* iPhone 16 Pro & Mobile optimizations */
    @media (max-width: 430px) {
      /* iPhone 16 Pro specific (430x932px) */
      .game-canvas {
        width: 95vw;
        height: 75vh; /* Increased from 55vh to show full game area */
        max-width: 420px; /* Increased to use more screen space */
        max-height: 700px; /* Increased to accommodate taller game */
      }
      
      .game-ui {
        width: 95%;
        padding: 10px;
        margin-bottom: env(safe-area-inset-bottom, 20px);
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
      }
      
      .start-text {
        font-size: clamp(1.8rem, 6vw, 2.2rem);
        margin: 15px;
      }
      
      .game-logo {
        width: clamp(180px, 45vw, 300px);
        margin-bottom: 20px;
      }
      
      .help-btn {
        top: env(safe-area-inset-top, 15px);
        right: 15px;
        padding: 8px 16px;
        font-size: 0.9rem;
      }
      
      .credits {
        bottom: env(safe-area-inset-bottom, 30px);
      }
    }
    
    @media (max-width: 768px) {
      .game-canvas {
        width: 95vw;
        height: 70vh; /* Increased for better mobile visibility */
        max-width: 420px;
        max-height: 650px;
      }
      
      .game-ui {
        flex-wrap: wrap;
        gap: 8px;
        padding: 12px;
        width: 95%;
      }
      
      .score-item {
        flex: 1;
        min-width: 70px;
      }
      
      .score-value {
        font-size: 1.2rem;
      }
      
      .score-label {
        font-size: 0.8rem;
      }
    }
    
    /* Landscape mobile */
    @media (max-height: 500px) and (orientation: landscape) {
      .intro-screen {
        flex-direction: row;
        gap: 20px;
        padding: 20px;
      }
      
      .game-logo {
        width: clamp(120px, 25vw, 200px);
        margin: 0;
      }
      
      .start-text {
        font-size: clamp(1.2rem, 4vw, 1.8rem);
        margin: 10px;
      }
      
      .game-canvas {
        height: 85vh; /* Increased to use more landscape space */
        max-height: 400px;
        width: 95vw;
      }
    }
  </style>
</head>
<body>
  <!-- Intro Screen -->
  <div class="intro-screen" id="introScreen">
    <div class="laser-effects">
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
    </div>
    
    <img src="img/logo.png" alt="BenBlinko Logo" class="game-logo" id="gameLogo">
    <div class="start-text" id="startText">🚀 CLICK TO START 🚀</div>
    <div class="credits">by BensBar</div>
    <button class="help-btn" id="helpBtn">❓ Help</button>
  </div>

  <!-- Help Screen -->
  <div class="help-screen" id="helpScreen">
    <div class="help-content">
      <h2>🎮 How to Play BenBlinko</h2>
      
      <div class="help-section">
        <h3>🎯 Basic Gameplay</h3>
        <p>• Click or tap to drop balls from the top</p>
        <p>• Balls bounce off pegs and land in scoring slots</p>
        <p>• Higher slots = bigger points!</p>
        <p>• Try to get high scores with your 5 balls</p>
      </div>
      
      <div class="help-section">
        <h3>📱 Mobile Controls</h3>
        <p>• Tap anywhere to drop a ball</p>
        <p>• Tilt your device left/right to guide balls</p>
        <p>• Haptic feedback when balls score</p>
      </div>
      
      <div class="help-section">
        <h3>🔥 Combo System</h3>
        <p>• Hit pegs in sequence to build a combo counter</p>
        <p>• Each peg hit increases your combo by 1</p>
        <p>• When ball lands in slot: get 10% bonus per combo hit</p>
        <p>• Example: 5 combo hits = 50% bonus to slot score!</p>
        <p>• Combo resets after each ball (landed or lost)</p>
      </div>
      
      <div class="help-section">
        <h3>⚡ Special Ball Types</h3>
        <p>� <strong>Normal Ball:</strong> Standard bouncy ball (85% chance)</p>
        <p>🔴 <strong>Explosive Ball:</strong> Creates big explosion hitting many pegs</p>
        <p>� <strong>Magnetic Ball:</strong> Attracted to special rainbow pegs</p>
        <p>🟡 <strong>Lightning Ball:</strong> Moves faster with electric speed</p>
        <p><em>Special balls appear randomly (15% chance total)</em></p>
      </div>
      
      <div class="help-section">
        <h3>🏆 Scoring Tips</h3>
        <p>• Aim for center slots (higher values)</p>
        <p>• Build long combos for bonus multipliers</p>
        <p>• Special pegs (rainbow) give extra effects</p>
        <p>• Use device tilt to fine-tune ball direction</p>
      </div>
    </div>
    
    <button class="close-help-btn" id="closeHelpBtn">✅ Got It!</button>
  </div>
  
  <!-- Game Container -->
  <div class="game-container" id="gameContainer">
    <canvas class="game-canvas" id="gameCanvas" width="800" height="800"></canvas>
    
    <div class="game-ui">
      <div class="score-item">
        <div class="score-label">SCORE</div>
        <div class="score-value" id="scoreValue">0</div>
      </div>
      
      <div class="score-item">
        <div class="score-label">HIGH SCORE</div>
        <div class="score-value" id="highScoreValue">0</div>
      </div>
      
      <div class="score-item">
        <div class="score-label">BALLS LEFT</div>
        <div class="score-value" id="ballsValue">5</div>
      </div>
      
      <div class="score-item">
        <div class="score-label">MULTIPLIER</div>
        <div class="score-value multiplier" id="multiplierValue">x1</div>
      </div>
    </div>
  </div>
  
  <!-- Game Over Screen -->
  <div class="game-over" id="gameOverScreen">
    <div class="laser-effects">
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
      <div class="laser-beam"></div>
    </div>
    
    <div class="game-over-title">GAME OVER</div>
    <div class="final-score" id="finalScore"></div>
    <button class="play-again-btn" id="playAgainBtn">🎮 PLAY AGAIN 🎮</button>
  </div>

  <script>
    // 🚀 BENBLINKO 4K NEON LASER DELUXE 🚀
    console.log("🚀 BenBlinko 4K Neon Laser Deluxe Loading...");
    
    // Game Elements
    const introScreen = document.getElementById('introScreen');
    const gameContainer = document.getElementById('gameContainer');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const helpScreen = document.getElementById('helpScreen');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startText = document.getElementById('startText');
    const gameLogo = document.getElementById('gameLogo');
    const helpBtn = document.getElementById('helpBtn');
    const closeHelpBtn = document.getElementById('closeHelpBtn');
    const playAgainBtn = document.getElementById('playAgainBtn');
    
    // UI Elements
    const scoreValue = document.getElementById('scoreValue');
    const highScoreValue = document.getElementById('highScoreValue');
    const ballsValue = document.getElementById('ballsValue');
    const multiplierValue = document.getElementById('multiplierValue');
    const finalScore = document.getElementById('finalScore');
    
    // Game State
    let gameState = 'intro'; // intro, playing, gameOver
    let score = 0;
    let highScore = 0;
    let ballsLeft = 5;
    let multiplier = 1;
    let balls = [];
    let pegs = [];
    let particles = [];
    let slots = [];
    
    // Load logo image for use in digital island
    const logoImage = new Image();
    logoImage.src = 'img/logo.png';
    let logoLoaded = false;
    logoImage.onload = () => {
      logoLoaded = true;
      console.log('Logo image loaded for digital island');
    };
    logoImage.onerror = () => {
      console.log('Could not load logo image, using text fallback');
    };
    
    // Game Constants - BADASS EDITION
    const GRAVITY = 0.3;
    const BOUNCE = 0.5; // Reduced from 0.8 to prevent excessive bouncing
    const PEG_RADIUS = 8;
    const BALL_RADIUS = 12;
    const SLOT_VALUES = [100, 500, 1000, 5000, 10000, 5000, 1000, 500, 100];
    const SLOT_COLORS = ['#ff006e', '#00d4ff', '#00ff88', '#ffff00', '#ff6600', '#ffff00', '#00ff88', '#00d4ff', '#ff006e'];
    
    // BADASS NEW FEATURES
    let comboCount = 0;
    let maxCombo = 0;
    let ballSpeed = 0;
    let totalBounces = 0;
    let fireworksActive = false;
    let screenShakeIntensity = 0;
    let soundEnabled = true;
    
    // Power-up system
    let powerUpActive = false;
    let powerUpType = 'normal'; // normal, explosive, magnetic, lightning
    const powerUpChance = 0.15; // 15% chance for power-up ball
    
    // Load high score
    try {
      const saved = localStorage.getItem('benblinko_highscore');
      if (saved) highScore = parseInt(saved);
    } catch (e) {
      console.log('Could not load high score');
    }
    
    // Initialize Canvas
    function initCanvas() {
      // Set canvas size directly - made taller for better mobile experience
      canvas.width = 800;
      canvas.height = 800; // Increased from 600 to 800 for better mobile visibility
      
      // High quality rendering
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      createPegs();
      createSlots();
    }
    
    // Create Pegs
    function createPegs() {
      pegs = [];
      const rows = 12;
      const pegsPerRow = 10; // Increased from 9 to 10 for even wider coverage
      const pegSpacing = 65; // Reduced from 70 to 65 to fit more pegs wider
      const rowSpacing = 40;
      const startY = 80; // Reduced from 120 to give more space without digital island
      
      for (let row = 0; row < rows; row++) {
        // Stagger every other row by offsetting odd rows
        const isOddRow = row % 2 === 1;
        const pegCount = pegsPerRow;
        const offsetX = isOddRow ? pegSpacing / 2 : 0;
        const startX = (canvas.width - (pegCount - 1) * pegSpacing) / 2 + offsetX;
        
        for (let col = 0; col < pegCount; col++) {
          pegs.push({
            x: startX + col * pegSpacing,
            y: startY + row * rowSpacing,
            radius: PEG_RADIUS,
            hit: false,
            special: Math.random() < 0.1, // 10% chance for special pegs that grant extra balls
            glowPhase: Math.random() * Math.PI * 2
          });
        }
      }
      
      console.log(`Created ${pegs.length} pegs with proper alternating stagger pattern`);
    }
    
    // Create Slots
    function createSlots() {
      slots = [];
      const slotWidth = canvas.width / SLOT_VALUES.length;
      
      for (let i = 0; i < SLOT_VALUES.length; i++) {
        slots.push({
          x: i * slotWidth,
          y: canvas.height - 120,  // Now at y=680 (800-120) for taller canvas
          width: slotWidth,
          height: 50,
          value: SLOT_VALUES[i],
          color: SLOT_COLORS[i]
        });
      }
      
      console.log(`Created ${slots.length} slots`);
    }
    
    // Ball Class - BADASS EDITION
    class Ball {
      constructor(x, y, type = 'normal') {
        this.x = x;
        this.y = y || 70; // Start below the top logo area
        this.vx = (Math.random() - 0.5) * 1;
        this.vy = 0;
        this.radius = BALL_RADIUS;
        this.trail = [];
        this.glowPhase = 0;
        this.bounceCount = 0;
        this.type = type;
        this.age = 0;
        this.explosionTriggered = false;
        
        // Set badass ball properties based on type
        switch(type) {
          case 'explosive':
            this.color = '#ff4444';
            this.explosionRadius = 80;
            break;
          case 'magnetic':
            this.color = '#8844ff';
            this.magneticForce = 3;
            break;
          case 'lightning':
            this.color = '#ffff44';
            this.speedMultiplier = 1.8;
            break;
          default:
            this.color = '#00d4ff';
        }
        
        this.sparkles = []; // Add sparkle effects for badass visuals
      }
      
      update() {
        // BADASS PHYSICS UPDATE
        this.age++;
        this.bounceCount = totalBounces;
        
        // Apply special ball physics
        if (this.type === 'lightning') {
          this.vy += GRAVITY * this.speedMultiplier;
          this.vx *= this.speedMultiplier;
        } else {
          this.vy += GRAVITY;
        }
        
        // Magnetic ball attraction to special pegs
        if (this.type === 'magnetic') {
          pegs.forEach(peg => {
            if (peg.special) {
              const dx = peg.x - this.x;
              const dy = peg.y - this.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < 100) {
                const force = this.magneticForce / distance;
                this.vx += (dx / distance) * force * 0.1;
                this.vy += (dy / distance) * force * 0.1;
              }
            }
          });
        }
        this.x += this.vx;
        this.y += this.vy;
        
        // Enhanced air resistance to prevent excessive bouncing
        this.vx *= 0.988; // Increased resistance
        this.vy *= 0.995;
        
        // Velocity dampening to prevent wild bouncing
        if (Math.abs(this.vx) > 8) this.vx *= 0.8;
        if (Math.abs(this.vy) > 12) this.vy *= 0.8;
        
        // Trail effect
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 10) this.trail.shift();
        
        this.glowPhase += 0.1;
        
        // Enhanced wall bouncing with visual effects and stronger collision
        if (this.x - this.radius <= 0) {
          this.x = this.radius;
          this.vx = Math.abs(this.vx) * BOUNCE;
          // Ensure ball doesn't get stuck in wall
          if (this.vx < 0.5) this.vx = 0.5;
          // Create wall bounce particles
          createParticles(this.x, this.y, '#ff006e', 8);
        }
        if (this.x + this.radius >= canvas.width) {
          this.x = canvas.width - this.radius;
          this.vx = -Math.abs(this.vx) * BOUNCE;
          // Ensure ball doesn't get stuck in wall
          if (this.vx > -0.5) this.vx = -0.5;
          // Create wall bounce particles
          createParticles(this.x, this.y, '#ff006e', 8);
        }
        
        // Top boundary (prevent ball from going above digital island)
        if (this.y - this.radius < 0) {
          this.y = this.radius;
          this.vy = Math.abs(this.vy) * BOUNCE;
        }
        
        // Peg collision - allow multiple bounces per frame for realistic physics
        let collisionCount = 0;
        for (let i = 0; i < pegs.length && collisionCount < 3; i++) {
          const peg = pegs[i];
          const dx = this.x - peg.x;
          const dy = this.y - peg.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.radius + peg.radius) {
            collisionCount++;
            
            // Only track hit for visual effects and multiplier bonuses
            if (!peg.hit) {
              peg.hit = true;
              peg.hitTime = Date.now();
              comboCount++; // Increment combo counter
              maxCombo = Math.max(maxCombo, comboCount); // Track max combo
              totalBounces++;
              
              // EXPLOSIVE BALL BADASS EFFECT
              if (this.type === 'explosive' && !this.explosionTriggered) {
                this.explosionTriggered = true;
                // Activate all pegs within explosion radius
                pegs.forEach(nearPeg => {
                  const expDx = nearPeg.x - peg.x;
                  const expDy = nearPeg.y - peg.y;
                  const expDistance = Math.sqrt(expDx * expDx + expDy * expDy);
                  if (expDistance < this.explosionRadius) {
                    nearPeg.hit = true;
                    nearPeg.hitTime = Date.now();
                    if (nearPeg.special) {
                      multiplier = Math.min(multiplier + 1, 10);
                      ballsLeft++;
                    }
                  }
                });
                // MASSIVE EXPLOSION PARTICLES
                createParticles(peg.x, peg.y, '#ff4444', 100);
                createParticles(peg.x, peg.y, '#ffaa44', 50);
                createParticles(peg.x, peg.y, '#ffffff', 30);
                screenShakeIntensity = 15; // Screen shake effect
                fireworksActive = true;
                setTimeout(() => fireworksActive = false, 1000);
              }
              
              // Special pegs double the final slot score and grant extra ball
              if (peg.special) {
                multiplier = Math.min(multiplier + 1, 10);
                ballsLeft++;
                createParticles(peg.x, peg.y, '#00ff88', 30);
                console.log(`Special peg hit! Multiplier now ${multiplier}x, granted extra ball. Balls left: ${ballsLeft}`);
                updateUI();
              } else {
                createParticles(peg.x, peg.y, this.color, 15);
              }
            }
            
            // Physics collision response
            const overlap = this.radius + peg.radius - distance;
            if (distance > 0 && overlap > 0) {
              // Normalize and separate
              const nx = dx / distance;
              const ny = dy / distance;
              
              // Move ball out of peg
              this.x += nx * overlap;
              this.y += ny * overlap;
              
              // Reflect velocity with realistic physics
              const dot = this.vx * nx + this.vy * ny;
              this.vx -= 2 * dot * nx;
              this.vy -= 2 * dot * ny;
              
              // Add some random bounce for realistic Plinko effect
              this.vx += (Math.random() - 0.5) * 1.5;
              this.vy += (Math.random() - 0.5) * 0.5;
              
              // Apply bounce factor
              this.vx *= BOUNCE;
              this.vy *= BOUNCE;
            }
          }
        }
        
        // Slot collision with haptic feedback
        if (this.y + this.radius >= canvas.height - 120) {  // Updated to match new slot position
          if (!this.toRemove) {  // Only process if not already marked for removal
            const slotWidth = canvas.width / SLOT_VALUES.length;
            const slotIndex = Math.floor(this.x / slotWidth);
            if (slotIndex >= 0 && slotIndex < slots.length) {
              const slot = slots[slotIndex];
              let slotScore = slot.value * multiplier;
              
              // Add combo bonus - clear and simple!
              if (comboCount > 1) {
                const comboBonus = Math.floor(slotScore * (comboCount / 10)); // 10% bonus per combo hit
                slotScore += comboBonus;
                
                // Show combo bonus popup 
                const comboPopup = document.createElement('div');
                comboPopup.innerHTML = `🔥 COMBO x${comboCount}<br>+${comboBonus.toLocaleString()} BONUS!`;
                comboPopup.style.cssText = `
                  position: fixed;
                  left: ${(slotIndex + 0.5) * (100 / SLOT_VALUES.length)}%;
                  top: 60%;
                  transform: translateX(-50%);
                  color: #ffff00;
                  font-size: 1.2rem;
                  font-weight: bold;
                  font-family: 'Orbitron', monospace;
                  text-shadow: 0 0 15px #ffff00;
                  pointer-events: none;
                  z-index: 1006;
                  text-align: center;
                  animation: comboPopupFloat 2.5s ease-out forwards;
                `;
                
                // Add combo popup animation
                const comboStyle = document.createElement('style');
                comboStyle.textContent = `
                  @keyframes comboPopupFloat {
                    0% { opacity: 1; transform: translateX(-50%) translateY(0px) scale(1.2); }
                    20% { opacity: 1; transform: translateX(-50%) translateY(-10px) scale(1.3); }
                    100% { opacity: 0; transform: translateX(-50%) translateY(-40px) scale(0.9); }
                  }
                `;
                document.head.appendChild(comboStyle);
                document.body.appendChild(comboPopup);
                
                setTimeout(() => {
                  if (comboPopup.parentNode) comboPopup.remove();
                  if (comboStyle.parentNode) comboStyle.remove();
                }, 2500);
              }
              
              score += slotScore;
              
              // Enhanced visual feedback
              createParticles(this.x, this.y, slot.color, 40);
              
              // BADASS haptic feedback for mobile devices
              if ('vibrate' in navigator) {
                try {
                  // Different vibration patterns based on slot value
                  if (slot.value >= 10000) {
                    navigator.vibrate([150, 50, 150, 50, 300]); // MASSIVE jackpot pattern
                  } else if (slot.value >= 5000) {
                    navigator.vibrate([100, 40, 100, 40, 100]); // High value pattern
                  } else if (slot.value >= 1000) {
                    navigator.vibrate([80, 30, 80]); // Medium value pattern
                  } else {
                    navigator.vibrate(60); // Basic vibration
                  }
                  console.log(`Haptic feedback triggered for ${slot.value} point slot`);
                } catch (error) {
                  console.log('Haptic feedback error:', error);
                }
              } else {
                console.log('Haptic feedback not supported on this device');
              }
              
              // Visual slot scoring feedback
              const scorePopup = document.createElement('div');
              scorePopup.innerHTML = `+${slotScore.toLocaleString()}`;
              scorePopup.style.cssText = `
                position: fixed;
                left: ${(slotIndex + 0.5) * (100 / SLOT_VALUES.length)}%;
                top: 70%;
                transform: translateX(-50%);
                color: ${slot.color};
                font-size: 1.5rem;
                font-weight: bold;
                font-family: 'Orbitron', monospace;
                text-shadow: 0 0 10px ${slot.color};
                pointer-events: none;
                z-index: 1005;
                animation: scoreFloat 2s ease-out forwards;
              `;
              
              // Add floating score animation
              const style = document.createElement('style');
              style.textContent = `
                @keyframes scoreFloat {
                  0% { opacity: 1; transform: translateX(-50%) translateY(0px) scale(1); }
                  50% { opacity: 1; transform: translateX(-50%) translateY(-30px) scale(1.2); }
                  100% { opacity: 0; transform: translateX(-50%) translateY(-60px) scale(0.8); }
                }
              `;
              document.head.appendChild(style);
              document.body.appendChild(scorePopup);
              
              setTimeout(() => {
                if (scorePopup.parentNode) {
                  scorePopup.remove();
                }
                if (style.parentNode) {
                  style.remove();
                }
              }, 2000);
              
              console.log(`Ball scored ${slotScore} points in slot ${slotIndex} (value: ${slot.value})`);
            }
            
            // Mark for removal
            this.toRemove = true;
            ballsLeft--;
            multiplier = 1;
            
            // Reset combo after ball lands (this is where combo ends)
            comboCount = 0;
            
            updateUI();
            
            if (ballsLeft <= 0) {
              setTimeout(() => endGame(), 500);
            }
          }
        }
        
        // Remove balls that fall off screen
        if (this.y > canvas.height + 100) {
          if (!this.toRemove) {  // Only process if not already marked for removal
            this.toRemove = true;
            ballsLeft--;
            
            // Reset combo when ball is lost
            comboCount = 0;
            
            updateUI();
            
            if (ballsLeft <= 0) {
              setTimeout(() => endGame(), 500);
            }
          }
        }
      }
      
      draw() {
        ctx.save();
        
        // Enhanced trail effect with gradient
        for (let i = 0; i < this.trail.length; i++) {
          const alpha = (i / this.trail.length) * 0.5;
          const point = this.trail[i];
          const trailRadius = this.radius * (i / this.trail.length) * 0.8;
          
          // Trail gradient
          const trailGradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, trailRadius);
          trailGradient.addColorStop(0, this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0'));
          trailGradient.addColorStop(1, this.color + '00');
          
          ctx.globalAlpha = alpha;
          ctx.fillStyle = trailGradient;
          ctx.beginPath();
          ctx.arc(point.x, point.y, trailRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.globalAlpha = 1;
        
        // Enhanced main ball with multiple glow layers
        const glow = Math.sin(this.glowPhase) * 0.3 + 0.9;
        
        // Outer glow
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 25 * glow;
        
        // Ball gradient
        const ballGradient = ctx.createRadialGradient(
          this.x - 4, this.y - 4, 0,
          this.x, this.y, this.radius
        );
        ballGradient.addColorStop(0, '#ffffff');
        ballGradient.addColorStop(0.3, this.color);
        ballGradient.addColorStop(1, '#0066aa');
        
        ctx.fillStyle = ballGradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner highlight
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#ffffff66';
        ctx.beginPath();
        ctx.arc(this.x - 3, this.y - 3, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Outer ring
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius + 1, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
      }
    }
    
    // Particle Class
    class Particle {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.color = color;
        this.life = 1;
        this.decay = Math.random() * 0.02 + 0.01;
        this.size = Math.random() * 4 + 2;
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1; // gravity
        this.life -= this.decay;
        this.vx *= 0.99; // air resistance
      }
      
      draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    // Create Particles
    function createParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color));
      }
    }
    
    // Update UI - BADASS EDITION
    function updateUI() {
      scoreValue.textContent = score.toLocaleString();
      highScoreValue.textContent = highScore.toLocaleString();
      ballsValue.textContent = ballsLeft;
      multiplierValue.textContent = `x${multiplier}`;
      
      // Update max combo
      if (comboCount > maxCombo) maxCombo = comboCount;
      
      // Add badass combo indicator
      let comboIndicator = document.getElementById('comboIndicator');
      if (!comboIndicator) {
        comboIndicator = document.createElement('div');
        comboIndicator.id = 'comboIndicator';
        comboIndicator.style.cssText = `
          position: fixed;
          top: 60px;
          left: 50%;
          transform: translateX(-50%);
          background: linear-gradient(45deg, #ff006e, #ffff00);
          padding: 8px 16px;
          border-radius: 20px;
          color: white;
          font-weight: bold;
          font-size: 0.9rem;
          z-index: 1005;
          box-shadow: 0 0 20px #ff006e88;
          transition: all 0.3s ease;
        `;
        document.body.appendChild(comboIndicator);
      }
      
      if (comboCount > 1) {
        comboIndicator.textContent = `🔥 COMBO x${comboCount}`;
        comboIndicator.style.display = 'block';
        comboIndicator.style.transform = `translateX(-50%) scale(${Math.min(1.5, 1 + comboCount * 0.1)})`;
      } else {
        comboIndicator.style.display = 'none';
      }
    }
    
    // Drop Ball - BADASS EDITION
    function dropBall(x) {
      // Only allow one ball at a time
      if (ballsLeft > 0 && gameState === 'playing' && balls.length === 0) {
        // Determine ball type - POWER-UP SYSTEM!
        let ballType = 'normal';
        const rand = Math.random();
        if (rand < powerUpChance) {
          const powerTypes = ['explosive', 'magnetic', 'lightning'];
          ballType = powerTypes[Math.floor(Math.random() * powerTypes.length)];
          
          // Show power-up notification
          const powerUpMsg = document.createElement('div');
          powerUpMsg.innerHTML = `
            <div style="position: fixed; top: 100px; left: 50%; transform: translateX(-50%); 
                        background: linear-gradient(45deg, #ff4444, #ffff44); padding: 12px 20px; border-radius: 15px; 
                        color: white; font-size: 1rem; z-index: 1006; font-weight: bold; text-align: center;
                        box-shadow: 0 0 30px #ff444488;">
              🚀 ${ballType.toUpperCase()} BALL! 🚀
            </div>
          `;
          document.body.appendChild(powerUpMsg);
          
          setTimeout(() => {
            if (powerUpMsg.parentNode) {
              powerUpMsg.remove();
            }
          }, 2000);
        }
        
        console.log(`Dropping ${ballType} ball at position ${x}, balls left: ${ballsLeft}`);
        const clampedX = Math.max(BALL_RADIUS, Math.min(canvas.width - BALL_RADIUS, x));
        balls.push(new Ball(clampedX, 70, ballType)); // Start below the top logo
        // Don't reset combo here - let it build across the ball's journey
      } else if (balls.length > 0) {
        console.log(`Cannot drop ball: another ball is still active (${balls.length} balls active)`);
      } else {
        console.log(`Cannot drop ball: ballsLeft=${ballsLeft}, gameState=${gameState}`);
      }
    }
    
    // Start Game
    function startGame() {
      console.log("🎮 Starting BenBlinko!");
      
      gameState = 'playing';
      score = 0;
      ballsLeft = 5;
      multiplier = 1;
      balls = [];
      particles = [];
      
      // Reset pegs
      pegs.forEach(peg => {
        peg.hit = false;
      });
      
      introScreen.classList.add('hidden');
      gameContainer.classList.add('active');
      gameOverScreen.classList.remove('show');
      
      updateUI();
      
      console.log(`Game started with ${pegs.length} pegs and ${slots.length} slots`);
      
      // Auto-drop first ball after a short delay
      setTimeout(() => {
        console.log("Auto-dropping first ball");
        dropBall(canvas.width / 2);
      }, 1000);
    }
    
    // End Game
    function endGame() {
      gameState = 'gameOver';
      
      if (score > highScore) {
        highScore = score;
        try {
          localStorage.setItem('benblinko_highscore', highScore.toString());
        } catch (e) {}
      }
      
      finalScore.innerHTML = `
        <div>Final Score: <strong>${score.toLocaleString()}</strong></div>
        <div>High Score: <strong>${highScore.toLocaleString()}</strong></div>
      `;
      
      setTimeout(() => {
        gameOverScreen.classList.add('show');
      }, 1000);
    }
    
    // Reset Game
    function resetGame() {
      gameState = 'intro';
      gameContainer.classList.remove('active');
      gameOverScreen.classList.remove('show');
      introScreen.classList.remove('hidden');
      
      balls = [];
      particles = [];
      
      // Reset pegs
      pegs.forEach(peg => {
        peg.hit = false;
      });
    }
    
    // Draw Game - BADASS EDITION
    function draw() {
      // SCREEN SHAKE EFFECT
      if (screenShakeIntensity > 0) {
        const shakeX = (Math.random() - 0.5) * screenShakeIntensity;
        const shakeY = (Math.random() - 0.5) * screenShakeIntensity;
        ctx.save();
        ctx.translate(shakeX, shakeY);
        screenShakeIntensity *= 0.9; // Fade out shake
        if (screenShakeIntensity < 0.1) screenShakeIntensity = 0;
      }
      
      // Enhanced background with dynamic effects
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      if (fireworksActive) {
        gradient.addColorStop(0, '#3a1a3a');
        gradient.addColorStop(1, '#1a0a1a');
      } else {
        gradient.addColorStop(0, '#1a1a3a');
        gradient.addColorStop(1, '#0a0a1a');
      }
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      if (gameState !== 'playing') {
        if (screenShakeIntensity > 0) ctx.restore();
        return;
      }
      
      // Draw logo at top center
      ctx.save();
      
      if (logoLoaded) {
        // Draw the actual logo image at top center
        const logoScale = 0.2; // Slightly larger for better visibility
        const logoWidth = logoImage.width * logoScale;
        const logoHeight = logoImage.height * logoScale;
        const logoX = (canvas.width - logoWidth) / 2; // Center horizontally
        const logoY = 10; // Top margin
        
        // Add glow effect to the logo
        ctx.shadowColor = '#00d4ff';
        ctx.shadowBlur = 15;
        ctx.drawImage(logoImage, logoX, logoY, logoWidth, logoHeight);
        ctx.shadowBlur = 0;
      } else {
        // Fallback to text-based logo at top center
        ctx.fillStyle = '#00d4ff';
        ctx.font = 'bold 24px Orbitron, Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#00d4ff';
        ctx.shadowBlur = 15;
        ctx.fillText('BenBlinko', canvas.width / 2, 35);
        
        // Subtitle
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Orbitron, Arial, sans-serif';
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 8;
        ctx.fillText('4K NEON LASER DELUXE', canvas.width / 2, 55);
      }
      ctx.restore();
      
      // COMBO DISPLAY at top right
      if (comboCount > 1) {
        ctx.save();
        ctx.textAlign = 'right';
        ctx.fillStyle = comboCount > 5 ? '#ffff00' : '#ff006e';
        ctx.font = `bold ${Math.min(20 + comboCount * 2, 32)}px Orbitron`;
        ctx.shadowColor = comboCount > 5 ? '#ffff00' : '#ff006e';
        ctx.shadowBlur = 15 + comboCount * 2;
        ctx.fillText(`${comboCount}x COMBO!`, canvas.width - 20, 30);
        
        // Combo streak indicator
        ctx.fillStyle = '#ffffff88';
        ctx.font = '10px Orbitron';
        ctx.shadowBlur = 5;
        ctx.fillText(`MAX: ${maxCombo}`, canvas.width - 20, 45);
        ctx.restore();
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      // Draw invisible wall indicators (subtle glow on sides)
      ctx.strokeStyle = '#ff006e33';
      ctx.lineWidth = 1;
      ctx.shadowColor = '#ff006e';
      ctx.shadowBlur = 5;
      // Left wall
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, canvas.height);
      ctx.stroke();
      // Right wall
      ctx.beginPath();
      ctx.moveTo(canvas.width, 0);
      ctx.lineTo(canvas.width, canvas.height);
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      // Draw slots with enhanced 4K visuals
      slots.forEach((slot, index) => {
        ctx.save();
        
        // Enhanced slot background with gradient
        const slotGradient = ctx.createLinearGradient(slot.x, slot.y, slot.x, slot.y + slot.height);
        slotGradient.addColorStop(0, slot.color + '88');
        slotGradient.addColorStop(0.5, slot.color + 'BB');
        slotGradient.addColorStop(1, slot.color + '44');
        ctx.fillStyle = slotGradient;
        ctx.fillRect(slot.x, slot.y, slot.width, slot.height);
        
        // Glowing outer border
        ctx.strokeStyle = slot.color;
        ctx.lineWidth = 3;
        ctx.shadowColor = slot.color;
        ctx.shadowBlur = 15;
        ctx.strokeRect(slot.x, slot.y, slot.width, slot.height);
        
        // Remove top border to make it look like an open slot
        ctx.strokeStyle = '#1a1a3a'; // Match background
        ctx.lineWidth = 4;
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.moveTo(slot.x, slot.y);
        ctx.lineTo(slot.x + slot.width, slot.y);
        ctx.stroke();
        
        // Add inner glow effect
        ctx.shadowColor = slot.color;
        ctx.shadowBlur = 8;
        ctx.strokeStyle = slot.color + '66';
        ctx.lineWidth = 1;
        ctx.strokeRect(slot.x + 2, slot.y + 2, slot.width - 4, slot.height - 4);
        
        // Draw slot value with enhanced styling
        ctx.shadowColor = '#000000';
        ctx.shadowBlur = 3;
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 16px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText(slot.value.toLocaleString(), slot.x + slot.width / 2, slot.y + slot.height / 2 + 8);
        
        // Add a subtle highlight on high-value slots
        if (slot.value >= 5000) {
          ctx.fillStyle = '#ffffff22';
          ctx.fillRect(slot.x + 1, slot.y + 1, slot.width - 2, slot.height / 3);
        }
        
        ctx.restore();
      });
      
      // Draw bottom collection area
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, canvas.height - 70, canvas.width, 70);
      ctx.strokeStyle = '#00d4ff';
      ctx.lineWidth = 2;
      ctx.strokeRect(0, canvas.height - 70, canvas.width, 70);
      
      // Draw pegs with enhanced 4K visuals
      pegs.forEach((peg, index) => {
        ctx.save();
        
        // Dynamic glow based on time and position
        const glow = Math.sin(peg.glowPhase + Date.now() * 0.01) * 0.4 + 0.8;
        const pulseGlow = Math.sin(Date.now() * 0.005 + index * 0.3) * 0.2 + 0.8;
        
        // Pegs remain bright even when hit - no darkening effect
        
        if (peg.special) {
          // Special pegs - enhanced rainbow effect
          ctx.shadowColor = '#00ff88';
          ctx.shadowBlur = 20 * glow * pulseGlow;
          
          // Create rainbow gradient for special pegs
          const specialGradient = ctx.createRadialGradient(peg.x, peg.y, 0, peg.x, peg.y, peg.radius * 2);
          specialGradient.addColorStop(0, '#00ff88');
          specialGradient.addColorStop(0.3, '#00d4ff');
          specialGradient.addColorStop(0.6, '#ff006e');
          specialGradient.addColorStop(1, '#00ff88');
          ctx.fillStyle = specialGradient;
          
          // Extra outer glow ring
          ctx.beginPath();
          ctx.arc(peg.x, peg.y, peg.radius + 3, 0, Math.PI * 2);
          ctx.fillStyle = '#00ff8833';
          ctx.fill();
        } else {
          // Regular pegs - enhanced cyan glow
          ctx.shadowColor = '#00d4ff';
          ctx.shadowBlur = 15 * glow;
          
          // Enhanced gradient for regular pegs
          const pegGradient = ctx.createRadialGradient(peg.x - 3, peg.y - 3, 0, peg.x, peg.y, peg.radius);
          pegGradient.addColorStop(0, '#ffffff');
          pegGradient.addColorStop(0.3, '#00d4ff');
          pegGradient.addColorStop(1, '#0088cc');
          ctx.fillStyle = pegGradient;
        }
        
        // Main peg circle
        ctx.beginPath();
        ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner highlight
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#ffffff44';
        ctx.beginPath();
        ctx.arc(peg.x - 2, peg.y - 2, peg.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        // Subtle outer ring
        ctx.strokeStyle = peg.special ? '#00ff88' : '#00d4ff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(peg.x, peg.y, peg.radius + 1, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
      });
      
      // Draw balls
      balls.forEach((ball, index) => {
        ball.draw();
      });
      
      // Draw particles
      particles = particles.filter(particle => {
        particle.update();
        particle.draw();
        return particle.life > 0;
      });
      
      // Debug info
      if (gameState === 'playing') {
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Pegs: ${pegs.length}`, 10, 20);
        ctx.fillText(`Balls: ${balls.length}`, 10, 35);
        ctx.fillText(`Particles: ${particles.length}`, 10, 50);
      }
    }
    
    // Game Loop
    function gameLoop() {
      try {
        if (gameState === 'playing') {
          // Update balls
          balls.forEach(ball => {
            if (!ball.toRemove) {
              ball.update();
            }
          });
          
          // Remove balls marked for removal
          const initialBallCount = balls.length;
          balls = balls.filter(ball => !ball.toRemove);
          
          // Debug logging for ball removal
          if (initialBallCount !== balls.length) {
            console.log(`Removed ${initialBallCount - balls.length} balls, ${balls.length} remaining, ${ballsLeft} balls left`);
          }
        }
        
        draw();
      } catch (error) {
        console.error('Game loop error:', error);
      }
      
      requestAnimationFrame(gameLoop);
    }
    
    // Event Listeners
    startText.addEventListener('click', startGame);
    gameLogo.addEventListener('click', startGame);
    
    canvas.addEventListener('click', (e) => {
      if (gameState === 'playing') {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        console.log(`Dropping ball at x: ${x}`);
        dropBall(x);
      }
    });
    
    playAgainBtn.addEventListener('click', resetGame);
    
    helpBtn.addEventListener('click', () => {
      helpScreen.classList.add('visible');
    });
    
    closeHelpBtn.addEventListener('click', () => {
      helpScreen.classList.remove('visible');
    });
    
    // Close help screen when clicking outside content
    helpScreen.addEventListener('click', (e) => {
      if (e.target === helpScreen) {
        helpScreen.classList.remove('visible');
      }
    });
    
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (gameState === 'intro') {
          startGame();
        } else if (gameState === 'playing') {
          dropBall(canvas.width / 2);
        } else if (gameState === 'gameOver') {
          resetGame();
        }
      }
    });
    
    // Mobile Device Orientation & Accelerometer Support
    let tiltEnabled = false;
    let tilt = 0;
    let lastGamma = 0;
    const TILT_SENSITIVITY = 3.5; // Optimized for responsive control
    
    function handleDeviceOrientation(event) {
      if (!tiltEnabled || gameState !== 'playing') return;
      
      // Get the device orientation data
      let gamma = event.gamma || 0; // Left/right tilt (-90 to 90)
      let beta = event.beta || 0;   // Front/back tilt (-180 to 180)
      let alpha = event.alpha || 0; // Compass direction (0-360)
      
      // Account for different device orientations
      let orientation = window.screen && window.screen.orientation ? 
                       window.screen.orientation.angle : 
                       (window.orientation || 0);
      
      // Correct tilt values based on device orientation
      let adjustedTilt = gamma;
      switch (orientation) {
        case 90: // Landscape left (rotated counter-clockwise)
          adjustedTilt = beta;
          break;
        case -90: // Landscape right (rotated clockwise)
        case 270: // Landscape right (270 degrees)
          adjustedTilt = -beta;
          break;
        case 180: // Portrait upside down
          adjustedTilt = -gamma;
          break;
        default: // Portrait (0 degrees)
          adjustedTilt = gamma;
          break;
      }
      
      // Apply sensitivity and bounds - increased sensitivity for better responsiveness
      const rawTilt = adjustedTilt * TILT_SENSITIVITY / 15; // Increased sensitivity
      const targetTilt = Math.max(-8, Math.min(8, rawTilt)); // Wider range
      
      // Smooth interpolation with quicker response
      tilt = tilt * 0.6 + targetTilt * 0.4;
      
      // Apply tilt force directly to active balls with enhanced effect
      balls.forEach(ball => {
        if (!ball.toRemove) {
          // Apply horizontal force based on tilt
          const tiltForce = tilt * 0.05; // Increased force multiplier
          ball.vx += tiltForce;
          
          // Prevent excessive horizontal velocity
          ball.vx = Math.max(-12, Math.min(12, ball.vx));
        }
      });
    }
    
    function requestMotionPermission() {
      // Show tilt enable button on mobile devices
      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        const tiltBtn = document.createElement('button');
        tiltBtn.innerHTML = '📱 Enable Tilt Control';
        tiltBtn.style.cssText = `
          position: absolute;
          bottom: 80px;
          left: 50%;
          transform: translateX(-50%);
          background: linear-gradient(45deg, #00d4ff, #ff006e);
          border: none;
          padding: 12px 24px;
          border-radius: 25px;
          color: white;
          font-weight: bold;
          cursor: pointer;
          font-size: 1rem;
          z-index: 1002;
          box-shadow: 0 0 20px #00d4ff88;
          transition: all 0.3s ease;
        `;
        
        // Add hover effect
        tiltBtn.addEventListener('mouseenter', () => {
          tiltBtn.style.transform = 'translateX(-50%) scale(1.05)';
        });
        
        tiltBtn.addEventListener('mouseleave', () => {
          tiltBtn.style.transform = 'translateX(-50%) scale(1)';
        });
        
        tiltBtn.addEventListener('click', async () => {
          try {
            // Disable button during request
            tiltBtn.disabled = true;
            tiltBtn.innerHTML = '🔄 Requesting Permission...';
            
            // Check for iOS 13+ permission system
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
              
              console.log('Requesting iOS motion permission...');
              const permission = await DeviceOrientationEvent.requestPermission();
              
              if (permission === 'granted') {
                console.log('iOS motion permission granted');
                enableTiltControl();
                tiltBtn.remove();
              } else {
                console.log('iOS motion permission denied:', permission);
                tiltBtn.innerHTML = '❌ Permission Denied';
                tiltBtn.style.background = 'linear-gradient(45deg, #ff4444, #cc0000)';
                
                setTimeout(() => {
                  tiltBtn.innerHTML = '📱 Enable Tilt Control';
                  tiltBtn.style.background = 'linear-gradient(45deg, #00d4ff, #ff006e)';
                  tiltBtn.disabled = false;
                }, 2000);
                
                // Show helpful message
                const helpMsg = document.createElement('div');
                helpMsg.innerHTML = `
                  <div style="position: fixed; bottom: 140px; left: 50%; transform: translateX(-50%); 
                              background: rgba(255,68,68,0.9); padding: 12px 20px; border-radius: 15px; 
                              color: white; font-size: 0.9rem; z-index: 1004; text-align: center; max-width: 280px;">
                    To enable tilt control:<br>
                    1. Go to Safari Settings<br>
                    2. Enable Motion & Orientation Access<br>
                    3. Refresh this page
                  </div>
                `;
                document.body.appendChild(helpMsg);
                
                setTimeout(() => {
                  if (helpMsg.parentNode) {
                    helpMsg.remove();
                  }
                }, 5000);
              }
            } else {
              // Android devices or older browsers - test if orientation events work
              console.log('Non-iOS device or older browser, testing orientation support...');
              
              // Test if we can receive orientation events
              let testTimeout = setTimeout(() => {
                console.log('Orientation events not supported or blocked');
                tiltBtn.innerHTML = '❌ Not Supported';
                tiltBtn.style.background = 'linear-gradient(45deg, #ff4444, #cc0000)';
                setTimeout(() => {
                  tiltBtn.remove();
                }, 2000);
              }, 2000);
              
              const testOrientation = (event) => {
                clearTimeout(testTimeout);
                window.removeEventListener('deviceorientation', testOrientation);
                console.log('Orientation events working on non-iOS device');
                enableTiltControl();
                tiltBtn.remove();
              };
              
              window.addEventListener('deviceorientation', testOrientation, { once: true });
            }
          } catch (error) {
            console.error('Motion permission error:', error);
            
            // Try to enable anyway for older devices/browsers
            tiltBtn.innerHTML = '🔄 Enabling...';
            
            setTimeout(() => {
              try {
                enableTiltControl();
                tiltBtn.remove();
              } catch (fallbackError) {
                console.error('Fallback enable failed:', fallbackError);
                tiltBtn.innerHTML = '❌ Failed';
                tiltBtn.style.background = 'linear-gradient(45deg, #ff4444, #cc0000)';
                setTimeout(() => tiltBtn.remove(), 2000);
              }
            }, 1000);
          }
        });
        
        document.getElementById('introScreen').appendChild(tiltBtn);
      }
    }
    
    function enableTiltControl() {
      tiltEnabled = true;
      
      // Add event listeners for device orientation with better browser support
      if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', handleDeviceOrientation, { passive: false });
        
        // Some browsers support absolute orientation events (more stable)
        if ('ondeviceorientationabsolute' in window) {
          window.addEventListener('deviceorientationabsolute', handleDeviceOrientation, { passive: false });
        }
      }
      
      // Show tilt indicator with real-time feedback
      const tiltIndicator = document.createElement('div');
      tiltIndicator.id = 'tiltIndicator';
      tiltIndicator.innerHTML = `
        <div style="position: fixed; top: 10px; left: 10px; 
                    background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 10px; 
                    color: #00d4ff; font-size: 0.8rem; z-index: 1003; font-family: monospace;
                    border: 1px solid #00d4ff44; backdrop-filter: blur(5px);">
          📱 Tilt: <span id="tiltValue">0.0</span>° | Orient: <span id="orientValue">0</span>°
        </div>
      `;
      document.body.appendChild(tiltIndicator);
      
      // Update tilt display with detailed info
      const updateTiltDisplay = () => {
        const tiltValueElement = document.getElementById('tiltValue');
        const orientValueElement = document.getElementById('orientValue');
        
        if (tiltValueElement && tiltEnabled) {
          tiltValueElement.textContent = tilt.toFixed(1);
        }
        
        if (orientValueElement) {
          const orientation = window.screen && window.screen.orientation ? 
                             window.screen.orientation.angle : 
                             (window.orientation || 0);
          orientValueElement.textContent = orientation;
        }
      };
      
      // Update display every 100ms
      const tiltDisplayInterval = setInterval(updateTiltDisplay, 100);
      
      // Store interval ID to clear it later if needed
      window.tiltDisplayInterval = tiltDisplayInterval;
      
      console.log('Tilt control enabled for mobile device');
      
      // Show success message with instructions
      const successMsg = document.createElement('div');
      successMsg.innerHTML = `
        <div style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); 
                    background: rgba(0,255,136,0.9); padding: 12px 20px; border-radius: 15px; 
                    color: white; font-size: 0.9rem; z-index: 1004; text-align: center;
                    box-shadow: 0 0 20px rgba(0,255,136,0.5); max-width: 300px;">
          ✅ Tilt control enabled!<br>
          <small>Tilt your device left/right to guide the ball</small>
        </div>
      `;
      document.body.appendChild(successMsg);
      
      setTimeout(() => {
        if (successMsg.parentNode) {
          successMsg.remove();
        }
      }, 4000);
      
      // Test orientation immediately
      setTimeout(() => {
        console.log('Testing initial device orientation...');
        if (window.DeviceOrientationEvent) {
          // Dispatch a test event to see if the handler works
          console.log('Device orientation support confirmed');
        }
      }, 500);
    }
    
    // Disable tilt control (for cleanup)
    function disableTiltControl() {
      tiltEnabled = false;
      tilt = 0;
      
      // Remove event listeners
      window.removeEventListener('deviceorientation', handleDeviceOrientation);
      window.removeEventListener('deviceorientationabsolute', handleDeviceOrientation);
      
      // Clear display update interval
      if (window.tiltDisplayInterval) {
        clearInterval(window.tiltDisplayInterval);
        window.tiltDisplayInterval = null;
      }
      
      // Remove tilt indicator
      const tiltIndicator = document.getElementById('tiltIndicator');
      if (tiltIndicator) {
        tiltIndicator.remove();
      }
      
      console.log('Tilt control disabled');
    }
    
    // Touch controls for mobile with improved responsiveness
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchStartTime = Date.now();
    }, { passive: false });
    
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      
      if (gameState === 'playing') {
        const touchDuration = Date.now() - touchStartTime;
        
        // Only register as tap if touch was brief (< 300ms) and didn't move much
        if (touchDuration < 300) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const x = (touchStartX - rect.left) * scaleX;
          
          // Ensure ball is dropped within canvas bounds
          const clampedX = Math.max(BALL_RADIUS, Math.min(canvas.width - BALL_RADIUS, x));
          console.log(`Touch drop at x: ${clampedX} (original: ${x})`);
          dropBall(clampedX);
        }
      }
    }, { passive: false });
    
    // Prevent scrolling on the canvas
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });
    
    // Initialize motion controls
    window.addEventListener('load', () => {
      setTimeout(requestMotionPermission, 1000);
    });
    
    // Initialize
    window.addEventListener('load', () => {
      console.log("🚀 BenBlinko 4K Neon Laser Deluxe Loaded!");
      initCanvas();
      updateUI();
      gameLoop();
    });
    
    window.addEventListener('resize', initCanvas);
    
    console.log("🚀 BenBlinko 4K Neon Laser Deluxe Ready!");
  </script>
</body>
</html>
