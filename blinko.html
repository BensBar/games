<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BenBlinko: Play & Tilt!</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Manrope:wght@700&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; width: 100%;
      background: #141a29;
      font-family: 'Manrope', 'Orbitron', Arial, sans-serif;
      overflow: hidden;
      color: #fff;
    }
    #bg-anim {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      z-index: 0;
      pointer-events: none;
    }
    #game-container {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100vw; height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      z-index: 2;
    }
    #ui-bar {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 40px;
      margin: 18px 0 0 0;
      z-index: 4;
      text-shadow: 0 2px 18px #7fd7f8, 0 0 2px #333;
      font-size: 1.25em;
      pointer-events: none;
      user-select: none;
    }
    #score-box, #highscore-box {
      background: rgba(0,0,0,0.33);
      padding: 12px 28px;
      border-radius: 15px;
      border: 2px solid #7fd7f8;
      font-weight: bold;
      color: #7fd7f8;
      text-shadow: 0 0 10px #7fd7f8, 0 0 4px #000;
      letter-spacing: 1.2px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1.22em;
    }
    .score-icon {
      font-size: 1.32em;
      filter: drop-shadow(0 0 6px #b7aaf7);
      margin-right: 3px;
    }
    #help-btn {
      margin-left: 24px;
      padding: 9px 22px;
      border-radius: 10px;
      border: 2px solid #7fd7f8;
      background: #1d2438;
      color: #7fd7f8;
      font-size: 1.15em;
      cursor: pointer;
      font-family: inherit;
      font-weight: bold;
      box-shadow: 0 2px 12px #7fd7f855;
      pointer-events: auto;
      transition: 0.13s;
    }
    #help-btn:hover {
      background: #7fd7f8;
      color: #1d2438;
      border-color: #b7aaf7;
    }
    #game-canvas {
      display: block;
      margin: 0 auto;
      background: transparent;
      border: 4px solid #7fd7f8;
      border-radius: 34px;
      box-shadow: 0 0 80px #b7aaf7a5, 0 0 24px #1a2237;
      z-index: 2;
      /* Size is set by JS */
      margin-bottom: 6px;
    }
    #debug {
      font-size: 1.12em;
      margin-top: 2px;
      color: #7fd7f8;
      text-shadow: 0 0 8px #7fd7f8, 0 0 2px #111;
      text-align: center;
      width: 100vw;
      opacity: 0.66;
    }
    #instructions {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(23,29,55,0.97);
      display: none;
      align-items: center; justify-content: center;
      z-index: 10;
      text-align: center;
      flex-direction: column;
      border-radius: 0;
      padding: 0;
      animation: fadeIn 0.6s;
    }
    #instructions.visible { display: flex; }
    #instructions-content {
      background: rgba(32,38,56,0.98);
      border-radius: 27px;
      padding: 40px 28px 30px 28px;
      box-shadow: 0 8px 44px #7fd7f8bb;
      border: 3px solid #7fd7f8;
      max-width: 96vw;
      animation: popIn 0.45s cubic-bezier(.32,1.56,.53,.92);
    }
    #instructions h2 {
      font-size: 2.2em;
      margin-bottom: 0.4em;
      color: #7fd7f8;
      text-shadow: 0 0 34px #7fd7f8;
      letter-spacing: 1.2px;
    }
    #instructions ul {
      text-align: left;
      margin: 0 auto 18px auto;
      padding-left: 20px;
      max-width: 440px;
      color: #fff;
      font-size: 1.2em;
      line-height: 1.8;
      text-shadow: 0 0 6px #7fd7f822, 0 0 2px #111;
    }
    #instructions button {
      margin-top: 22px;
      font-size: 1.15em;
      padding: 10px 28px;
      border-radius: 10px;
      border: none;
      background: linear-gradient(90deg,#7fd7f8,#b7aaf7);
      color: #1d2438;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 10px #7fd7f8c9;
      transition: 0.12s;
    }
    #instructions button:hover {
      background: #b7aaf7;
      color: #222;
    }
    #welcome {
      position: absolute;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(22,28,48,0.965);
      z-index: 15;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.7s;
    }
    #welcome h1 {
      font-size: 3.1em;
      margin: 0.5em;
      text-shadow: 0 0 38px #7fd7f8, 0 0 65px #b7aaf7;
      letter-spacing: 3px;
      color: #7fd7f8;
      font-family: Orbitron, Manrope, Arial, sans-serif;
    }
    #welcome p {
      font-size: 1.28em;
      margin: 0.3em 0 1em;
      color: #fff;
      text-shadow: 0 0 10px #111a;
      max-width: 430px;
      font-family: 'Manrope', Arial, sans-serif;
    }
    #start-btn {
      padding: 16px 38px;
      font-size: 1.45em;
      border: none;
      border-radius: 18px;
      background: linear-gradient(90deg, #7fd7f8 40%, #b7aaf7 100%);
      color: #1d2438;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 8px 36px #7fd7f8bb, 0 2px 12px #b7aaf7aa;
      transition: 0.15s;
      margin-top: 1em;
    }
    #start-btn:hover {
      background: linear-gradient(90deg, #b7aaf7, #7fd7f8);
      color: #000;
      transform: scale(1.07);
    }
    @keyframes fadeIn {
      from { opacity:0 }
      to { opacity:1 }
    }
    @keyframes popIn {
      0%   { transform: scale(0.9);}
      100% { transform: scale(1);}
    }
    @media (max-width: 700px) {
      #instructions-content { font-size: 1em; }
      #welcome h1 { font-size: 2.1em;}
    }
  </style>
</head>
<body>
  <canvas id="bg-anim"></canvas>
  <div id="game-container">
    <div id="ui-bar">
      <span id="score-box"><span class="score-icon">üèÜ</span><span id="score-val">0</span></span>
      <span id="highscore-box"><span class="score-icon">‚≠ê</span><span id="highscore-val">0</span></span>
      <button id="help-btn" style="pointer-events:auto;">‚ùî</button>
    </div>
    <canvas id="game-canvas"></canvas>
    <div id="debug"></div>
  </div>
  <div id="instructions">
    <div id="instructions-content">
      <h2>How to Play</h2>
      <ul>
        <li><b>Tilt your device</b> (or use <b>left/right arrow keys</b>) to steer the ball.</li>
        <li>The ball bounces off pegs. Land in the <b>center slot</b> for the best prize!</li>
        <li>Your <b>score</b> and <b>high score</b> are shown at the top.</li>
      </ul>
      <button id="close-instructions">Back</button>
    </div>
  </div>
  <div id="welcome">
    <h1>BenBlinko</h1>
    <p>Tilt your device (or use arrow keys) to steer the ball.<br>
    Bounce off pegs and land in a slot for points!<br>
    Try to beat your high score!</p>
    <button id="start-btn">Start Game</button>
    <button id="help-btn-welcome" style="margin-top:20px;">How to Play</button>
  </div>
  <script>
    // Animated gradient BG
    const bg = document.getElementById('bg-anim');
    bg.width = window.innerWidth; bg.height = window.innerHeight;
    const bgctx = bg.getContext('2d');
    let gradTime = 0;
    function drawBg() {
      gradTime += 0.007;
      let w = bg.width, h = bg.height;
      let g = bgctx.createLinearGradient(
        w/2 + Math.sin(gradTime)*w/4,
        h/2 + Math.cos(gradTime/2)*h/4,
        w/2 + Math.cos(gradTime)*w/3,
        h/2 + Math.sin(gradTime/3)*h/3
      );
      g.addColorStop(0, `#223d54`);
      g.addColorStop(0.25, `#4f6fb2`);
      g.addColorStop(0.55, `#7fd7f8`);
      g.addColorStop(0.81, `#b7aaf7`);
      g.addColorStop(1, `#141a29`);
      bgctx.fillStyle = g;
      bgctx.fillRect(0,0,w,h);
      requestAnimationFrame(drawBg);
    }
    drawBg();
    window.addEventListener('resize', () => {
      bg.width = window.innerWidth;
      bg.height = window.innerHeight;
    });

    // Responsive Canvas
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      // 9:16 aspect ratio, fill screen
      const ww = window.innerWidth;
      const wh = window.innerHeight - 40; // allow for score bar
      let w = ww, h = wh;
      if (w / h > 9/16) w = h * 9/16;
      else h = w * 16/9;
      canvas.width = w;
      canvas.height = h;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Game elements scale
    let tilt = 0, tiltReady = false;
    let score = 0;
    let highscore = parseInt(localStorage.getItem('blinkoHighScore')||'0')||0;
    document.getElementById('score-val').textContent = score;
    document.getElementById('highscore-val').textContent = highscore;

    // Board setup (relative to canvas)
    function getBoardSpec() {
      const w = canvas.width, h = canvas.height;
      // Board area
      const boardMarginX = w*0.04, boardMarginY = h*0.04;
      const boardW = w - 2*boardMarginX;
      const boardH = h - 2*boardMarginY - h*0.10;
      const slotCount = 7;
      const pegRows = 10;
      const pegCols = 10;
      // Peg/ball ratio is further reduced to prevent ball sticking
      const pegRadius = boardW*0.015; // smaller pegs
      const ballRadius = boardW*0.0275; // smaller ball
      const slotH = boardH*0.1;
      return {
        x: boardMarginX,
        y: boardMarginY,
        w: boardW,
        h: boardH,
        slotCount,
        pegRows,
        pegCols,
        pegRadius,
        ballRadius,
        slotH
      };
    }

    // Peg/Slot/Reward/Color
    function getSlots(spec) {
      return Array.from({length: spec.slotCount}, (_, i) => ({
        x: spec.x + i*(spec.w/spec.slotCount),
        w: spec.w/spec.slotCount,
        reward: [10,40,120,350,120,40,10][i],
        color: [
          "#7fd7f8", "#b7aaf7", "#8dd6e8", "#7fd7f8",
          "#8dd6e8", "#b7aaf7", "#7fd7f8"
        ][i]
      }));
    }
    function getPegs(spec) {
      let pegs = [];
      for (let row = 0; row < spec.pegRows; row++) {
        for (let col = 0; col < spec.pegCols; col++) {
          let xOffset = (row%2 ? (spec.w/spec.pegCols)/2 : 0);
          let px = spec.x + col*(spec.w/spec.pegCols) + xOffset;
          let py = spec.y + row*((spec.h-spec.slotH*1.15)/spec.pegRows) + spec.pegRadius*1.6;
          pegs.push({x: px, y: py, sparkle: 0});
        }
      }
      return pegs;
    }

    // Ball, Trail, Confetti
    let ball = null, ballTrail = [],
        slots = [], pegs = [], spec = getBoardSpec();

    // For stuck detection / nudge
    let lastX = 0, xSameCount = 0;

    function spawnBall() {
      spec = getBoardSpec();
      slots = getSlots(spec);
      pegs = getPegs(spec);
      ball = {
        x: spec.x + spec.w/2,
        y: spec.y + spec.ballRadius,
        r: spec.ballRadius,
        vx: 0,
        vy: 0,
        hue: Math.floor(Math.random()*360),
        stopped: false,
        slotIdx: -1,
        confetti: []
      };
      ballTrail = [];
      lastX = ball.x;
      xSameCount = 0;
    }

    function update() {
      if (!ball || ball.stopped) return;
      // Smooth physics, gentle gravity
      ball.vy += spec.h*0.00018;
      ball.vx += tilt * 0.012;
      ball.x += ball.vx;
      ball.y += ball.vy;
      ball.hue = (ball.hue + 2) % 360;

      // Ball trail
      ballTrail.unshift({x: ball.x, y: ball.y, hue: ball.hue});
      if (ballTrail.length > 38) ballTrail.pop();

      // Wall bounce & gentle inward nudge at edge
      if (ball.x - ball.r < spec.x) {
        ball.x = spec.x + ball.r + 0.2;
        ball.vx = Math.abs(ball.vx)*0.65 + 0.7;
      }
      if (ball.x + ball.r > spec.x + spec.w) {
        ball.x = spec.x + spec.w - ball.r - 0.2;
        ball.vx = -Math.abs(ball.vx)*0.65 - 0.7;
      }

      // Peg collisions (with extra nudge to prevent sticking)
      pegs.forEach(p => {
        const dx = ball.x - p.x;
        const dy = ball.y - p.y;
        const dist = Math.hypot(dx, dy);
        if (dist < ball.r + spec.pegRadius) {
          const angle = Math.atan2(dy, dx);
          const overlap = ball.r + spec.pegRadius - dist + 0.6;
          ball.x += Math.cos(angle) * overlap;
          ball.y += Math.sin(angle) * overlap;
          // Bounce with randomness
          const nudge = (Math.random()-0.5)*1.05;
          ball.vx = Math.cos(angle + Math.PI/2) * 0.73 + nudge;
          ball.vy *= 0.91 + (Math.random()-0.5)*0.11;
          // If near edge, force a bigger nudge inward
          if (ball.x < spec.x + spec.w*0.12) ball.vx += 0.5 + Math.random()*0.4;
          if (ball.x > spec.x + spec.w*0.88) ball.vx -= 0.5 + Math.random()*0.4;
          p.sparkle = 1.0;
        }
        p.sparkle *= 0.93;
      });

      // Ball stuck on side peg? Nudge toward center if horizontal pos is unchanged for a while
      if (Math.abs(ball.x - lastX) < 0.6) xSameCount++;
      else xSameCount = 0;
      lastX = ball.x;
      if (xSameCount > 13) {
        if (ball.x < spec.x + spec.w/2) ball.vx += 0.95+Math.random();
        else ball.vx -= 0.95+Math.random();
        xSameCount = 0;
      }

      // Ball lands in slot
      if (ball.y + ball.r >= spec.y + spec.h - spec.slotH) {
        ball.stopped = true;
        const idx = slots.findIndex(s => ball.x > s.x && ball.x < s.x + s.w);
        if (idx !== -1) {
          ball.x = slots[idx].x + slots[idx].w / 2;
          score += slots[idx].reward;
          document.getElementById('score-val').textContent = score;
          if (score > highscore) {
            highscore = score;
            document.getElementById('highscore-val').textContent = highscore;
            localStorage.setItem('blinkoHighScore', highscore);
          }
          ball.slotIdx = idx;
          // Confetti burst
          for (let i=0; i<18; ++i) {
            ball.confetti.push({
              x: ball.x,
              y: spec.y + spec.h - spec.slotH,
              vx: Math.cos(i/18*2*Math.PI)* (1.1+Math.random()*1.3) * (spec.w/320),
              vy: -2.2 - Math.random()*2.2 * (spec.h/540),
              color: slots[idx].color,
              t: 0
            });
          }
        }
        setTimeout(spawnBall, 1100);
      }

      // Confetti physics
      if (ball && ball.confetti) {
        for (let c of ball.confetti) {
          c.x += c.vx;
          c.y += c.vy;
          c.vy += spec.h*0.00015;
          c.t += 1;
        }
        ball.confetti = ball.confetti.filter(c => c.y < canvas.height && c.t < 70);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw slots
      slots.forEach((s, i) => {
        ctx.save();
        let pulse = (ball && ball.stopped && ball.slotIdx === i) ? (1+Math.sin(performance.now()/80))/2 : 0;
        ctx.fillStyle = s.color;
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = 28*pulse;
        ctx.fillRect(s.x, spec.y + spec.h - spec.slotH, s.w, spec.slotH);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.14;
        ctx.fillStyle = '#000';
        ctx.fillRect(s.x, spec.y + spec.h - spec.slotH - 8, s.w, 8);
        ctx.globalAlpha = 1;
        ctx.font = `bold ${Math.round(spec.slotH*0.33)}px Orbitron, monospace`;
        ctx.fillStyle = '#223d54';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = 11;
        ctx.fillText(s.reward, s.x + s.w / 2, spec.y + spec.h - spec.slotH/2);
        ctx.restore();
      });

      // Draw pegs
      pegs.forEach(p => {
        ctx.save();
        if (p.sparkle > 0.05) {
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 18*p.sparkle;
          ctx.fillStyle = `rgba(255,255,255,${p.sparkle})`;
        } else {
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#fff';
        }
        ctx.beginPath();
        ctx.arc(p.x, p.y, spec.pegRadius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      });

      // Ball trail (soft)
      for (let i=ballTrail.length-1; i>0; i--) {
        let t = i/ballTrail.length;
        ctx.save();
        ctx.beginPath();
        ctx.arc(ballTrail[i].x, ballTrail[i].y, ball.r*(0.83+0.23*t), 0, Math.PI*2);
        ctx.globalAlpha = 0.09 + 0.11*t;
        ctx.fillStyle = `hsl(${ballTrail[i].hue},63%,${61+10*t}%)`;
        ctx.shadowColor = "#b7aaf7";
        ctx.shadowBlur = 15*t;
        ctx.fill();
        ctx.restore();
      }

      // Draw ball
      if (ball) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        ctx.fillStyle = `hsl(${ball.hue},66%,72%)`;
        ctx.shadowColor = '#b7aaf7';
        ctx.shadowBlur = 27;
        ctx.globalAlpha = 0.98;
        ctx.fill();
        ctx.restore();
      }

      // Confetti
      if (ball && ball.confetti) {
        for (let c of ball.confetti) {
          ctx.save();
          ctx.globalAlpha = Math.max(0, 1 - c.t/70);
          ctx.fillStyle = c.color;
          ctx.beginPath();
          ctx.arc(c.x, c.y, 2.1+Math.sin(c.t/3)*1.2, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
      }
    }

    function loop() {
      update();
      draw();
      document.getElementById('debug').textContent = '';
      requestAnimationFrame(loop);
    }

    function initTilt() {
      if (window.DeviceOrientationEvent?.requestPermission) {
        DeviceOrientationEvent.requestPermission().then(p => {
          if (p === 'granted') {
            tiltReady = true;
            window.addEventListener('deviceorientation', onTilt);
          }
        });
      } else {
        window.addEventListener('deviceorientation', onTilt);
        tiltReady = true;
      }
    }
    function onTilt(e) { tilt = e.gamma || 0; }

    // Start
    document.getElementById('start-btn').onclick = () => {
      document.getElementById('welcome').style.display = 'none';
      document.getElementById('game-container').style.display = 'flex';
      resizeCanvas(); // ensure full screen
      spawnBall();
      score = 0;
      document.getElementById('score-val').textContent = score;
      initTilt();
      requestAnimationFrame(loop);
    };

    // Help/instructions modal
    function showInstructions() { document.getElementById('instructions').classList.add('visible'); }
    function hideInstructions() { document.getElementById('instructions').classList.remove('visible'); }
    document.getElementById('help-btn').onclick = showInstructions;
    document.getElementById('help-btn-welcome').onclick = showInstructions;
    document.getElementById('close-instructions').onclick = hideInstructions;

    // Keyboard for desktop
    window.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') tilt -= 2;
      if (e.key === 'ArrowRight') tilt += 2;
      if (e.key === 'Escape') hideInstructions();
    });

    // Highscore on reload
    window.addEventListener('DOMContentLoaded', ()=>{
      highscore = parseInt(localStorage.getItem('blinkoHighScore')||'0')||0;
      document.getElementById('highscore-val').textContent = highscore;
    });

    // Recalc and redraw on resize
    window.addEventListener('resize', () => {
      resizeCanvas();
      spec = getBoardSpec();
      slots = getSlots(spec);
      pegs = getPegs(spec);
    });
  </script>
</body>
</html>