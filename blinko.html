<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BenBlinko: Tilt to Win</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; width: 100%;
      background: #141a29;
      font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
      overflow: hidden;
      color: #fff;
    }
    #game-container {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100vw; height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }
    #ui-bar {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 32px;
      margin: 16px 0 4px 0;
      z-index: 4;
      text-shadow: 0 2px 18px #7fd7f8, 0 0 2px #333;
      font-size: 1.2em;
      pointer-events: none;
      user-select: none;
    }
    #score-box, #highscore-box {
      background: rgba(0,0,0,0.36);
      padding: 7px 18px;
      border-radius: 10px;
      border: 1.5px solid #6ec6e8;
      font-weight: bold;
      color: #6ec6e8;
      text-shadow: 0 0 10px #7fd7f8, 0 0 4px #000;
      letter-spacing: 0.5px;
    }
    #help-btn {
      margin-left: 16px;
      padding: 6px 16px;
      border-radius: 8px;
      border: 1px solid #7fd7f8;
      background: #1d2438;
      color: #7fd7f8;
      font-size: 1em;
      cursor: pointer;
      font-family: inherit;
      font-weight: bold;
      box-shadow: 0 2px 8px #7fd7f850;
      pointer-events: auto;
      transition: 0.13s;
    }
    #help-btn:hover {
      background: #7fd7f8;
      color: #1d2438;
      border-color: #7fd7f8;
    }
    #game-canvas {
      display: block;
      background: linear-gradient(180deg,#1c2340 0%,#21305e 100%);
      border: 3px solid #7fd7f8;
      border-radius: 26px;
      box-shadow: 0 0 60px #8ec6f840, 0 0 18px #1a2237;
      margin: auto;
      z-index: 2;
    }
    #debug {
      font-size: 1.07em;
      margin-top: 2px;
      color: #7fd7f8;
      text-shadow: 0 0 8px #7fd7f8, 0 0 2px #111;
      text-align: center;
      width: 100vw;
    }
    #instructions {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(22,28,48,0.97);
      display: none;
      align-items: center; justify-content: center;
      z-index: 10;
      text-align: center;
      flex-direction: column;
      border-radius: 0;
      padding: 0;
    }
    #instructions.visible { display: flex; }
    #instructions-content {
      background: rgba(32,38,56,0.96);
      border-radius: 22px;
      padding: 32px 28px 20px 28px;
      box-shadow: 0 8px 40px #80e8fd99;
      border: 2.5px solid #7fd7f8;
      max-width: 97vw;
    }
    #instructions h2 {
      font-size: 2em;
      margin-bottom: 0.3em;
      color: #7fd7f8;
      text-shadow: 0 0 22px #7fd7f8;
      letter-spacing: 1px;
    }
    #instructions ul {
      text-align: left;
      margin: 0 auto 18px auto;
      padding-left: 20px;
      max-width: 420px;
      color: #fff;
      font-size: 1.12em;
      line-height: 1.7;
      text-shadow: 0 0 6px #7fd7f822, 0 0 2px #111;
    }
    #instructions button {
      margin-top: 12px;
      font-size: 1.1em;
      padding: 8px 24px;
      border-radius: 8px;
      border: none;
      background: linear-gradient(90deg,#7fd7f8,#b7aaf7);
      color: #1d2438;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 7px #7fd7f8c9;
      transition: 0.12s;
    }
    #instructions button:hover {
      background: #b7aaf7;
      color: #222;
    }
    #welcome {
      position: absolute;
      top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(22,28,48,0.955);
      z-index: 15;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #welcome h1 {
      font-size: 3em;
      margin: 0.5em;
      text-shadow: 0 0 34px #7fd7f8, 0 0 60px #b7aaf7;
      letter-spacing: 3px;
      color: #7fd7f8;
    }
    #welcome p {
      font-size: 1.25em;
      margin: 0.3em 0 1em;
      color: #fff;
      text-shadow: 0 0 10px #111a;
      max-width: 420px;
    }
    #start-btn {
      padding: 16px 36px;
      font-size: 1.4em;
      border: none;
      border-radius: 16px;
      background: linear-gradient(90deg, #7fd7f8 40%, #b7aaf7 100%);
      color: #1d2438;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 8px 32px #7fd7f8bb, 0 2px 8px #b7aaf7aa;
      transition: 0.15s;
      margin-top: 1em;
    }
    #start-btn:hover {
      background: linear-gradient(90deg, #b7aaf7, #7fd7f8);
      color: #000;
      transform: scale(1.07);
    }
    @media (max-width: 700px) {
      #instructions-content { font-size: 1em; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="ui-bar">
      <span id="score-box">Score: <span id="score-val">0</span></span>
      <span id="highscore-box">High: <span id="highscore-val">0</span></span>
      <button id="help-btn" style="pointer-events:auto;">?</button>
    </div>
    <canvas id="game-canvas"></canvas>
    <div id="debug">γ: 0°</div>
  </div>
  <div id="instructions">
    <div id="instructions-content">
      <h2>How to Play</h2>
      <ul>
        <li><b>Tilt your device</b> (or use <b>left/right arrow keys</b>) to steer the ball as it falls.</li>
        <li>The ball bounces off pegs. Aim for the <b>center slot</b> for the biggest reward!</li>
        <li>Your <b>score</b> and <b>high score</b> are shown at the top.</li>
      </ul>
      <button id="close-instructions">Back</button>
    </div>
  </div>
  <div id="welcome">
    <h1>BenBlinko</h1>
    <p>Tilt your device (or use arrow keys) to steer the ball.<br>
    Bounce off pegs and land in a slot for points!<br>
    Try to beat your high score!</p>
    <button id="start-btn">Start Game</button>
    <button id="help-btn-welcome" style="margin-top:20px;">How to Play</button>
  </div>
  <script>
    // Responsive Canvas
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      // 9:16 aspect ratio, fill screen
      const ww = window.innerWidth;
      const wh = window.innerHeight - 20; // allow for score bar
      let w = ww, h = wh;
      if (w / h > 9/16) w = h * 9/16;
      else h = w * 16/9;
      canvas.width = w;
      canvas.height = h;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Game elements scale
    let tilt = 0, tiltReady = false;
    let score = 0;
    let highscore = parseInt(localStorage.getItem('blinkoHighScore')||'0')||0;
    document.getElementById('score-val').textContent = score;
    document.getElementById('highscore-val').textContent = highscore;

    // Board setup (relative to canvas)
    function getBoardSpec() {
      const w = canvas.width, h = canvas.height;
      // Board area
      const boardMarginX = w*0.04, boardMarginY = h*0.04;
      const boardW = w - 2*boardMarginX;
      const boardH = h - 2*boardMarginY - h*0.10;
      const slotCount = 7;
      const pegRows = 10;
      const pegCols = 10;
      // Peg/ball ratio is reduced to prevent ball sticking
      const pegRadius = boardW*0.0185; // slightly smaller pegs
      const ballRadius = boardW*0.031; // slightly smaller ball
      const slotH = boardH*0.09;
      return {
        x: boardMarginX,
        y: boardMarginY,
        w: boardW,
        h: boardH,
        slotCount,
        pegRows,
        pegCols,
        pegRadius,
        ballRadius,
        slotH
      };
    }

    // Peg/Slot/Reward/Color
    function getSlots(spec) {
      return Array.from({length: spec.slotCount}, (_, i) => ({
        x: spec.x + i*(spec.w/spec.slotCount),
        w: spec.w/spec.slotCount,
        reward: [10,30,100,250,100,30,10][i],
        color: [
          "#7fd7f8", "#b7aaf7", "#8dd6e8", "#7fd7f8",
          "#8dd6e8", "#b7aaf7", "#7fd7f8"
        ][i]
      }));
    }
    function getPegs(spec) {
      let pegs = [];
      for (let row = 0; row < spec.pegRows; row++) {
        for (let col = 0; col < spec.pegCols; col++) {
          let xOffset = (row%2 ? (spec.w/spec.pegCols)/2 : 0);
          let px = spec.x + col*(spec.w/spec.pegCols) + xOffset;
          let py = spec.y + row*((spec.h-spec.slotH*1.15)/spec.pegRows) + spec.pegRadius*1.5;
          pegs.push({x: px, y: py, sparkle: 0});
        }
      }
      return pegs;
    }

    // Ball, Trail, Confetti
    let ball = null, ballTrail = [], slots = [], pegs = [], spec = getBoardSpec();

    function spawnBall() {
      spec = getBoardSpec();
      slots = getSlots(spec);
      pegs = getPegs(spec);
      ball = {
        x: spec.x + spec.w/2,
        y: spec.y + spec.ballRadius,
        r: spec.ballRadius,
        vx: 0,
        vy: 0,
        hue: Math.floor(Math.random()*360),
        stopped: false,
        slotIdx: -1,
        confetti: []
      };
      ballTrail = [];
    }

    function update() {
      if (!ball || ball.stopped) return;
      // Smooth physics, gentle gravity
      ball.vy += spec.h*0.00019;
      ball.vx += tilt * 0.012;
      ball.x += ball.vx;
      ball.y += ball.vy;
      ball.hue = (ball.hue + 2) % 360;

      // Ball trail
      ballTrail.unshift({x: ball.x, y: ball.y, hue: ball.hue});
      if (ballTrail.length > 34) ballTrail.pop();

      // Wall bounce
      if (ball.x - ball.r < spec.x) {
        ball.x = spec.x + ball.r;
        ball.vx *= -0.45;
      }
      if (ball.x + ball.r > spec.x + spec.w) {
        ball.x = spec.x + spec.w - ball.r;
        ball.vx *= -0.45;
      }

      // Peg collisions (with extra nudge to prevent sticking)
      pegs.forEach(p => {
        const dx = ball.x - p.x;
        const dy = ball.y - p.y;
        const dist = Math.hypot(dx, dy);
        if (dist < ball.r + spec.pegRadius) {
          const angle = Math.atan2(dy, dx);
          const overlap = ball.r + spec.pegRadius - dist + 0.7;
          ball.x += Math.cos(angle) * overlap;
          ball.y += Math.sin(angle) * overlap;
          // Bounce with slight randomness to avoid sticking
          const nudge = (Math.random()-0.5)*0.9;
          ball.vx = Math.cos(angle + Math.PI/2) * 0.63 + nudge;
          ball.vy *= 0.89 + (Math.random()-0.5)*0.10;
          p.sparkle = 1.0;
        }
        p.sparkle *= 0.93;
      });

      // Ball lands in slot
      if (ball.y + ball.r >= spec.y + spec.h - spec.slotH) {
        ball.stopped = true;
        const idx = slots.findIndex(s => ball.x > s.x && ball.x < s.x + s.w);
        if (idx !== -1) {
          ball.x = slots[idx].x + slots[idx].w / 2;
          score += slots[idx].reward;
          document.getElementById('score-val').textContent = score;
          if (score > highscore) {
            highscore = score;
            document.getElementById('highscore-val').textContent = highscore;
            localStorage.setItem('blinkoHighScore', highscore);
          }
          ball.slotIdx = idx;
          // Confetti burst
          for (let i=0; i<18; ++i) {
            ball.confetti.push({
              x: ball.x,
              y: spec.y + spec.h - spec.slotH,
              vx: Math.cos(i/18*2*Math.PI)* (1.1+Math.random()*1.3) * (spec.w/320),
              vy: -2.2 - Math.random()*2.2 * (spec.h/540),
              color: slots[idx].color,
              t: 0
            });
          }
        }
        setTimeout(spawnBall, 1200);
      }

      // Confetti physics
      if (ball && ball.confetti) {
        for (let c of ball.confetti) {
          c.x += c.vx;
          c.y += c.vy;
          c.vy += spec.h*0.00014;
          c.t += 1;
        }
        ball.confetti = ball.confetti.filter(c => c.y < canvas.height && c.t < 70);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw slots
      slots.forEach((s, i) => {
        ctx.save();
        let pulse = (ball && ball.stopped && ball.slotIdx === i) ? (1+Math.sin(performance.now()/80))/2 : 0;
        ctx.fillStyle = s.color;
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = 24*pulse;
        ctx.fillRect(s.x, spec.y + spec.h - spec.slotH, s.w, spec.slotH);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.17;
        ctx.fillStyle = '#000';
        ctx.fillRect(s.x, spec.y + spec.h - spec.slotH - 8, s.w, 8);
        ctx.globalAlpha = 1;
        ctx.font = `bold ${Math.round(spec.slotH*0.36)}px Orbitron, monospace`;
        ctx.fillStyle = '#21305e';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = 9;
        ctx.fillText(s.reward, s.x + s.w / 2, spec.y + spec.h - spec.slotH/2);
        ctx.restore();
      });

      // Draw pegs
      pegs.forEach(p => {
        ctx.save();
        if (p.sparkle > 0.05) {
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 16*p.sparkle;
          ctx.fillStyle = `rgba(255,255,255,${p.sparkle})`;
        } else {
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#fff';
        }
        ctx.beginPath();
        ctx.arc(p.x, p.y, spec.pegRadius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      });

      // Ball trail (soft)
      for (let i=ballTrail.length-1; i>0; i--) {
        let t = i/ballTrail.length;
        ctx.save();
        ctx.beginPath();
        ctx.arc(ballTrail[i].x, ballTrail[i].y, ball.r*(0.85+0.23*t), 0, Math.PI*2);
        ctx.globalAlpha = 0.09 + 0.12*t;
        ctx.fillStyle = `hsl(${ballTrail[i].hue},63%,${61+10*t}%)`;
        ctx.shadowColor = "#b7aaf7";
        ctx.shadowBlur = 8*t;
        ctx.fill();
        ctx.restore();
      }

      // Draw ball
      if (ball) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        ctx.fillStyle = `hsl(${ball.hue},56%,70%)`;
        ctx.shadowColor = '#b7aaf7';
        ctx.shadowBlur = 23;
        ctx.globalAlpha = 0.98;
        ctx.fill();
        ctx.restore();
      }

      // Confetti
      if (ball && ball.confetti) {
        for (let c of ball.confetti) {
          ctx.save();
          ctx.globalAlpha = Math.max(0, 1 - c.t/70);
          ctx.fillStyle = c.color;
          ctx.beginPath();
          ctx.arc(c.x, c.y, 2.1+Math.sin(c.t/3)*1.2, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
      }
    }

    function loop() {
      update();
      draw();
      document.getElementById('debug').textContent = `γ: ${tilt.toFixed(2)}° ${tiltReady ? '✓':'×'}`;
      requestAnimationFrame(loop);
    }

    function initTilt() {
      if (window.DeviceOrientationEvent?.requestPermission) {
        DeviceOrientationEvent.requestPermission().then(p => {
          if (p === 'granted') {
            tiltReady = true;
            window.addEventListener('deviceorientation', onTilt);
          }
        });
      } else {
        window.addEventListener('deviceorientation', onTilt);
        tiltReady = true;
      }
    }
    function onTilt(e) { tilt = e.gamma || 0; }

    // Start
    document.getElementById('start-btn').onclick = () => {
      document.getElementById('welcome').style.display = 'none';
      document.getElementById('game-container').style.display = 'flex';
      resizeCanvas(); // ensure full screen
      spawnBall();
      score = 0;
      document.getElementById('score-val').textContent = score;
      initTilt();
      requestAnimationFrame(loop);
    };

    // Help/instructions modal
    function showInstructions() { document.getElementById('instructions').classList.add('visible'); }
    function hideInstructions() { document.getElementById('instructions').classList.remove('visible'); }
    document.getElementById('help-btn').onclick = showInstructions;
    document.getElementById('help-btn-welcome').onclick = showInstructions;
    document.getElementById('close-instructions').onclick = hideInstructions;

    // Keyboard for desktop
    window.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') tilt -= 2;
      if (e.key === 'ArrowRight') tilt += 2;
      if (e.key === 'Escape') hideInstructions();
    });

    // Highscore on reload
    window.addEventListener('DOMContentLoaded', ()=>{
      highscore = parseInt(localStorage.getItem('blinkoHighScore')||'0')||0;
      document.getElementById('highscore-val').textContent = highscore;
    });

    // Recalc and redraw on resize
    window.addEventListener('resize', () => {
      resizeCanvas();
      spec = getBoardSpec();
      slots = getSlots(spec);
      pegs = getPegs(spec);
    });
  </script>
</body>
</html>