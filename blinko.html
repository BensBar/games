<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BenBlinko: Tilt to Win</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
      background: #1a1b2f;
      color: #fff;
    }
    #gradient-bg {
      position: fixed;
      top: 0; left: 0; width: 100vw; height: 100vh;
      z-index: 0;
      pointer-events: none;
    }
    #welcome, #game-container, #instructions {
      position: absolute;
      top: 0; left: 0; width: 100vw; height: 100vh;
      display: flex;
      align-items: center; justify-content: center;
      flex-direction: column;
      z-index: 2;
    }
    #welcome {
      background: rgba(16,18,38,0.85);
      z-index: 3;
    }
    #welcome h1 {
      font-size: 2.8em;
      margin: 0.5em;
      text-shadow: 0 0 20px #0ff, 0 0 40px #0ff6;
      letter-spacing: 2px;
    }
    #welcome p {
      font-size: 1.2em;
      margin: 0.3em 0 1em;
      color: #fff;
      text-shadow: 0 0 8px #0008;
    }
    #start-btn {
      padding: 16px 36px;
      font-size: 1.3em;
      border: none;
      border-radius: 16px;
      background: linear-gradient(90deg, #45a29e 40%, #58e0ff 100%);
      color: #1a1b2f;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 8px 32px #0ff4, 0 2px 8px #0006;
      transition: 0.2s;
      margin-top: 1em;
    }
    #start-btn:hover {
      background: linear-gradient(90deg, #66fcf1, #0ff);
      color: #000;
      transform: scale(1.05);
    }
    #game-container {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      z-index: 2;
    }
    #ui-bar {
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 32px;
      margin: 18px 0 6px 0;
      z-index: 4;
      text-shadow: 0 2px 18px #0ff8, 0 0 2px #333;
      font-size: 1.2em;
      user-select: none;
      pointer-events: none;
    }
    #score-box, #highscore-box {
      background: rgba(0,0,0,0.35);
      padding: 7px 18px;
      border-radius: 10px;
      border: 1.5px solid #45a29e;
      font-weight: bold;
    }
    #help-btn {
      margin-left: 16px;
      padding: 6px 16px;
      border-radius: 8px;
      border: 1px solid #0ff;
      background: #222e;
      color: #0ff;
      font-size: 1em;
      cursor: pointer;
      font-family: inherit;
      font-weight: bold;
      transition: 0.15s;
      box-shadow: 0 2px 8px #0ff3;
      pointer-events: auto;
    }
    #help-btn:hover {
      background: #0ff;
      color: #222;
      border-color: #66fcf1;
    }
    #instructions {
      background: rgba(18,18,48, 0.92);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
      text-align: center;
      flex-direction: column;
      border-radius: 24px;
      padding: 32px 28px 20px 28px;
      box-shadow: 0 8px 40px #0ff5;
    }
    #instructions.visible { display: flex; }
    #instructions h2 {
      font-size: 2em;
      margin-bottom: 0.3em;
      color: #0ff;
      letter-spacing: 1px;
      text-shadow: 0 0 12px #0ff6;
    }
    #instructions ul {
      text-align: left;
      margin: 0 auto 18px auto;
      padding-left: 20px;
      max-width: 420px;
      color: #fff;
      font-size: 1.05em;
      line-height: 1.7;
      text-shadow: 0 0 6px #0ff2, 0 0 2px #111;
    }
    #instructions button {
      margin-top: 12px;
      font-size: 1.1em;
      padding: 8px 24px;
      border-radius: 8px;
      border: none;
      background: linear-gradient(90deg,#45a29e,#0ff);
      color: #1a1b2f;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 7px #0ff3;
      transition: 0.12s;
    }
    #instructions button:hover {
      background: #66fcf1;
      color: #000;
    }
    #game {
      background: transparent;
      border: 2.5px solid #66fcf1;
      border-radius: 18px;
      box-shadow: 0 0 60px #0ff4, 0 0 12px #222;
      margin-bottom: 0.8em;
      z-index: 2;
    }
    #debug {
      font-size: 1.07em;
      margin-top: 2px;
      color: #0ff8;
      text-shadow: 0 0 8px #0ff5, 0 0 2px #111;
    }
    @media (max-width: 500px) {
      #game { width: 96vw !important; height: 63vw !important; }
      #ui-bar { font-size: 1em; }
      #instructions { font-size: 1em; }
    }
  </style>
</head>
<body>
  <canvas id="gradient-bg"></canvas>
  <div id="welcome">
    <h1>BenBlinko</h1>
    <p>Tilt your device (or use arrow keys) to steer the glowing ball.<br>
    Bounce off pegs and land in a slot for points!<br>
    How high can you score?</p>
    <button id="start-btn">Start Game</button>
    <button id="help-btn" style="margin-top:20px;">How to Play</button>
  </div>
  <div id="game-container">
    <div id="ui-bar">
      <span id="score-box">Score: <span id="score-val">0</span></span>
      <span id="highscore-box">High: <span id="highscore-val">0</span></span>
      <button id="help-btn" style="pointer-events:auto;">?</button>
    </div>
    <canvas id="game" width="360" height="540"></canvas>
    <div id="debug">γ: 0°</div>
  </div>
  <div id="instructions">
    <h2>How to Play</h2>
    <ul>
      <li><b>Tilt your device</b> (or use <b>left/right arrow keys</b> on desktop) to steer the ball as it falls.</li>
      <li>The ball bounces off glowing pegs. Try to land it in the center slot for the most points!</li>
      <li>Each slot is worth a different reward. Collect as many points as you can!</li>
      <li>Your <b>high score</b> is saved. Can you beat it?</li>
    </ul>
    <button id="close-instructions">Back</button>
  </div>
  <script>
    // Animated gradient background
    const gradientBg = document.getElementById('gradient-bg');
    gradientBg.width = window.innerWidth;
    gradientBg.height = window.innerHeight;
    const gctx = gradientBg.getContext('2d');
    let gradTime = 0;
    function drawGradientBg() {
      gradTime += 0.006;
      let w = gradientBg.width, h = gradientBg.height;
      let g = gctx.createLinearGradient(
        w/2 + Math.sin(gradTime)*w/4,
        h/2 + Math.cos(gradTime/2)*h/4,
        w/2 + Math.cos(gradTime)*w/3,
        h/2 + Math.sin(gradTime/3)*h/3
      );
      g.addColorStop(0, `hsl(${(190+Math.sin(gradTime)*30)%360},90%,12%)`);
      g.addColorStop(0.38, `hsl(${(230+Math.cos(gradTime*2)*50)%360},97%,24%)`);
      g.addColorStop(0.66, `hsl(${(290+Math.sin(gradTime*1.3)*50)%360},99%,22%)`);
      g.addColorStop(1, `hsl(${(330+Math.cos(gradTime*1.7)*40)%360},92%,15%)`);
      gctx.fillStyle = g;
      gctx.fillRect(0,0,w,h);
      requestAnimationFrame(drawGradientBg);
    }
    drawGradientBg();
    window.addEventListener('resize', () => {
      gradientBg.width = window.innerWidth;
      gradientBg.height = window.innerHeight;
    });

    // Main Game Code
    const startBtn = document.getElementById('start-btn');
    const welcome = document.getElementById('welcome');
    const container = document.getElementById('game-container');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const debugEl = document.getElementById('debug');
    const helpBtns = document.querySelectorAll('#help-btn');
    const instructions = document.getElementById('instructions');
    const closeInstructions = document.getElementById('close-instructions');
    const scoreVal = document.getElementById('score-val');
    const highscoreVal = document.getElementById('highscore-val');
    let tilt = 0, tiltReady = false;

    // Game parameters
    const PEG_RADIUS = 7.5;
    const SLOT_COUNT = 7;
    const SLOTS = Array.from({length: SLOT_COUNT}, (_, i) => ({
      x: i * (canvas.width / SLOT_COUNT),
      w: canvas.width / SLOT_COUNT,
      reward: [10,30,75,180,75,30,10][i],
      color: `hsl(${i * 50},85%,62%)`
    }));
    const PEGS = [];
    for (let row = 0; row < 9; row++) {
      for (let col = 0; col < 10; col++) {
        const xOffset = row % 2 ? canvas.width / 20 : 0;
        PEGS.push({x: col * (canvas.width / 9) + xOffset, y: row * 52 + 48, sparkle: 0});
      }
    }

    let ball = null;
    let score = 0;
    let highscore = parseInt(localStorage.getItem('blinkoHighScore')||'0')||0;
    highscoreVal.textContent = highscore;

    // Ball trail
    let ballTrail = [];

    function spawnBall() {
      ball = {
        x: canvas.width / 2,
        y: 20,
        r: 13,
        vx: 0,
        vy: 0,
        hue: Math.floor(Math.random()*360),
        stopped: false,
        slotIdx: -1,
        confetti: []
      };
      ballTrail = [];
    }

    function update() {
      if (!ball || ball.stopped) return;
      // Gentle, smooth physics
      ball.vy += 0.075;
      ball.vx += tilt * 0.018;
      ball.x += ball.vx;
      ball.y += ball.vy;
      ball.hue = (ball.hue + 2) % 360;

      // Ball trail
      ballTrail.unshift({x: ball.x, y: ball.y, hue: ball.hue});
      if (ballTrail.length > 28) ballTrail.pop();

      // Wall bounce
      if (ball.x - ball.r < 0 || ball.x + ball.r > canvas.width) {
        ball.x = Math.max(ball.r, Math.min(canvas.width - ball.r, ball.x));
        ball.vx *= -0.43;
      }

      // Peg collisions
      PEGS.forEach(p => {
        const dx = ball.x - p.x;
        const dy = ball.y - p.y;
        const dist = Math.hypot(dx, dy);
        if (dist < ball.r + PEG_RADIUS) {
          const angle = Math.atan2(dy, dx);
          const overlap = ball.r + PEG_RADIUS - dist + 1;
          ball.x += Math.cos(angle) * overlap;
          ball.y += Math.sin(angle) * overlap;
          ball.vx = Math.cos(angle + Math.PI/2) * 0.7 + (Math.random()-0.5)*0.2;
          ball.vy *= 0.87 + (Math.random()-0.5)*0.1;
          p.sparkle = 1.0;
        }
        p.sparkle *= 0.93;
      });

      // Ball lands in slot
      if (ball.y + ball.r >= canvas.height - 30) {
        ball.stopped = true;
        const idx = SLOTS.findIndex(s => ball.x > s.x && ball.x < s.x + s.w);
        if (idx !== -1) {
          ball.x = SLOTS[idx].x + SLOTS[idx].w / 2;
          score += SLOTS[idx].reward;
          scoreVal.textContent = score;
          if (score > highscore) {
            highscore = score;
            highscoreVal.textContent = highscore;
            localStorage.setItem('blinkoHighScore', highscore);
          }
          ball.slotIdx = idx;
          // Confetti burst
          for (let i=0; i<21; ++i) {
            ball.confetti.push({
              x: ball.x,
              y: canvas.height - 30,
              vx: Math.cos(i/21*2*Math.PI)* (1.2+Math.random()*1.7),
              vy: -2 - Math.random()*3,
              color: `hsl(${SLOTS[idx].color.match(/\d+/g)[0]*1+Math.random()*90},98%,70%)`,
              t: 0
            });
          }
        }
        setTimeout(spawnBall, 1250);
      }

      // Confetti physics
      if (ball && ball.confetti) {
        for (let c of ball.confetti) {
          c.x += c.vx;
          c.y += c.vy;
          c.vy += 0.08;
          c.t += 1;
        }
        ball.confetti = ball.confetti.filter(c => c.y < canvas.height && c.t < 70);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Draw slots, highlight if ball landed
      SLOTS.forEach((s, i) => {
        ctx.save();
        let pulse = (ball && ball.stopped && ball.slotIdx === i) ? (1+Math.sin(performance.now()/80))/2 : 0;
        ctx.fillStyle = `hsl(${i*50},80%,${62+10*pulse}%)`;
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = 22*pulse;
        ctx.fillRect(s.x, canvas.height - 30, s.w, 30);
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#111a';
        ctx.fillRect(s.x, canvas.height - 38, s.w, 8);
        ctx.fillStyle = '#000';
        ctx.font = 'bold 16px Orbitron, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(s.reward, s.x + s.w / 2, canvas.height - 13);
        ctx.restore();
      });

      // Draw pegs
      PEGS.forEach(p => {
        ctx.save();
        if (p.sparkle > 0.05) {
          ctx.shadowColor = "#fff";
          ctx.shadowBlur = 14*p.sparkle;
          ctx.fillStyle = `rgba(255,255,255,${p.sparkle})`;
        } else {
          ctx.shadowBlur = 0;
          ctx.fillStyle = '#e0faff';
        }
        ctx.beginPath();
        ctx.arc(p.x, p.y, PEG_RADIUS, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      });

      // Ball trail
      for (let i=ballTrail.length-1; i>0; i--) {
        let t = i/ballTrail.length;
        ctx.save();
        ctx.beginPath();
        ctx.arc(ballTrail[i].x, ballTrail[i].y, ball.r*(0.8+0.4*t), 0, Math.PI*2);
        ctx.globalAlpha = 0.09 + 0.13*t;
        ctx.fillStyle = `hsl(${ballTrail[i].hue},100%,${60+10*t}%)`;
        ctx.shadowColor = "#0ff";
        ctx.shadowBlur = 22*t;
        ctx.fill();
        ctx.restore();
      }

      // Draw ball
      if (ball) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        ctx.fillStyle = `hsl(${ball.hue},100%,60%)`;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 36;
        ctx.globalAlpha = 0.99;
        ctx.fill();
        ctx.restore();
      }

      // Draw confetti
      if (ball && ball.confetti) {
        for (let c of ball.confetti) {
          ctx.save();
          ctx.globalAlpha = Math.max(0, 1 - c.t/70);
          ctx.fillStyle = c.color;
          ctx.beginPath();
          ctx.arc(c.x, c.y, 2.1+Math.sin(c.t/3)*1.4, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
      }
    }

    function loop() {
      update();
      draw();
      debugEl.textContent = `γ: ${tilt.toFixed(2)}° ${tiltReady ? '✓':'×'}`;
      requestAnimationFrame(loop);
    }

    function initTilt() {
      if (window.DeviceOrientationEvent?.requestPermission) {
        DeviceOrientationEvent.requestPermission().then(p => {
          if (p === 'granted') {
            tiltReady = true;
            window.addEventListener('deviceorientation', onTilt);
          }
        });
      } else {
        window.addEventListener('deviceorientation', onTilt);
        tiltReady = true;
      }
    }
    function onTilt(e) { tilt = e.gamma || 0; }

    startBtn.onclick = () => {
      welcome.style.display = 'none';
      container.style.display = 'flex';
      spawnBall();
      score = 0;
      scoreVal.textContent = score;
      initTilt();
      requestAnimationFrame(loop);
    };

    // Help/instructions modal
    for (let btn of helpBtns) btn.onclick = () => {
      instructions.classList.add('visible');
      instructions.focus();
    };
    closeInstructions.onclick = () => {
      instructions.classList.remove('visible');
    };

    // For desktop: arrow key tilt
    window.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') tilt -= 2;
      if (e.key === 'ArrowRight') tilt += 2;
      if (e.key === 'Escape') instructions.classList.remove('visible');
    });

    // Persistent highscore update on reload
    window.addEventListener('DOMContentLoaded', ()=>{
      highscore = parseInt(localStorage.getItem('blinkoHighScore')||'0')||0;
      highscoreVal.textContent = highscore;
    });

  </script>
</body>
</html>