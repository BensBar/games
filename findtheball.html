<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Find the Ball Under the Hat</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
    :root {
        --bg-top:#1c2533;
        --bg-bottom:#070b11;
        --accent:#f9b233;
        --correct:#42d66c;
        --wrong:#ff4d4d;
        --panel-bg:rgba(0,0,0,0.45);
        --font-stack: 'Segoe UI', Arial, sans-serif;
        --hat-color:#8b4513;
        --hat-rim:#654321;
    }
    body {
        margin:0;
        font-family:var(--font-stack);
        background: radial-gradient(circle at 50% 35%, #2f3d52 0%, #121821 60%, #070b11 100%);
        color:#fff;
        display:flex;
        flex-direction:column;
        align-items:center;
        min-height:100vh;
        overflow:hidden;
        user-select:none;
    }
    header {
        position:absolute;
        top:10px;
        width:100%;
        display:flex;
        justify-content:center;
        pointer-events:none;
    }
    #scoreboard {
        background:var(--panel-bg);
        backdrop-filter:blur(6px);
        padding:10px 22px;
        border-radius:18px;
        display:flex;
        gap:26px;
        font-size:15px;
        box-shadow:0 4px 18px -4px rgba(0,0,0,0.55);
        pointer-events:auto;
    }
    #scoreboard span.label { opacity:0.65; font-size:12px; display:block; letter-spacing:0.5px; text-transform:uppercase; }
    #scoreboard .value { font-weight:600; font-size:18px; }
    #container {
        position:relative;
        flex:1;
        display:flex;
        align-items:center;
        justify-content:center;
        width:100%;
    }
    canvas {
        width: min(1000px, 100%);
        aspect-ratio: 4 / 3;
        max-height: 82vh;
        border:1px solid rgba(255,255,255,0.15);
        border-radius:16px;
        background: linear-gradient(to bottom, var(--bg-top), var(--bg-bottom));
        box-shadow:0 10px 40px -10px rgba(0,0,0,0.7), 0 0 0 1px rgba(255,255,255,0.05) inset;
        cursor:pointer;
    }
    #messageBox {
        position:absolute;
        bottom:16px;
        left:50%;
        transform:translateX(-50%);
        background:var(--panel-bg);
        padding:14px 26px;
        border-radius:14px;
        font-size:20px;
        min-width:260px;
        text-align:center;
        backdrop-filter:blur(5px);
        box-shadow:0 6px 24px -6px rgba(0,0,0,0.65);
        transition:background .3s, color .3s, transform .35s ease;
        will-change:transform;
    }
    #controls {
        position:absolute;
        top:10px;
        right:16px;
        display:flex;
        gap:10px;
        z-index:10;
    }
    button {
        font:600 14px var(--font-stack);
        padding:10px 18px;
        background:linear-gradient(145deg,#f5b02c,#d59012);
        color:#14181f;
        border:none;
        border-radius:12px;
        cursor:pointer;
        letter-spacing:0.5px;
        box-shadow:0 4px 16px -4px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.15) inset;
        transition:transform .2s, box-shadow .2s, filter .3s;
    }
    button:active { transform:translateY(2px) scale(0.97); }
    button:hover { box-shadow:0 6px 22px -6px rgba(0,0,0,0.65); filter:brightness(1.05); }
    #hint {
        position:absolute;
        top:54px;
        right:16px;
        font-size:11px;
        opacity:0.4;
        max-width:200px;
        line-height:1.3;
        text-align:right;
    }
    .hidden { display:none; }
    @media (max-width: 720px) {
        #scoreboard { gap:14px; padding:8px 16px; }
        #scoreboard .value { font-size:15px; }
        canvas { border-radius:12px; }
        #messageBox { font-size:17px; padding:11px 18px; }
    }
</style>
</head>
<body>
    <header>
        <div id="scoreboard">
            <div><span class="label">Wins</span><span class="value" id="wins">0</span></div>
            <div><span class="label">Losses</span><span class="value" id="losses">0</span></div>
            <div><span class="label">Streak</span><span class="value" id="streak">0</span></div>
            <div><span class="label">Rounds</span><span class="value" id="rounds">0</span></div>
        </div>
    </header>
    <div id="controls">
        <button id="restartBtn" class="hidden">Play Again</button>
    </div>
    <div id="hint">Find the ball under a hat after the 20-second shuffle. Click to guess!</div>
    <div id="container">
        <canvas id="gameCanvas" width="1000" height="750" aria-label="Find the ball game area"></canvas>
        <div id="messageBox"></div>
    </div>

<script>
(function(){
'use strict';

/* ========== Canvas & DOM ========== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const messageBox = document.getElementById('messageBox');
const restartBtn = document.getElementById('restartBtn');

/* Scoreboard refs */
const winsEl = document.getElementById('wins');
const lossesEl = document.getElementById('losses');
const streakEl = document.getElementById('streak');
const roundsEl = document.getElementById('rounds');

/* ========== Game State ========== */
const HAT_W = 140;
const HAT_H = 100;
const BALL_RADIUS = 25;
let baseY = 360;
let positions = [];
let hats = [];
let hasBall = [];
let hoveredIndex = -1;

const SHUFFLE_TIME = 20000; // 20 seconds shuffle duration
const SWAP_INTERVAL_MIN = 400;
const SWAP_INTERVAL_MAX = 1000;

const LIFT_REVEAL_HEIGHT = 80;
const LIFT_DURATION = 800;

let state = 'ready'; // ready|showing|shuffling|guessing|revealing|result
let shuffleStart = 0;
let lastSwapTime = 0;
let nextSwapAfter = 0;
let revealStart = 0;
let chosenIndex = -1;
let correctIndex = 1; // Ball starts under center hat (hat 2, index 1)

let animationHandle = null;

/* Score tracking */
let wins = 0;
let losses = 0;
let streak = 0;
let rounds = 0;

/* Confetti */
let confettiPieces = [];

/* ========== Utility ========== */
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function lerp(a,b,t){ return a + (b - a) * t; }
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
function easeInOutQuad(t){ return t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }

/* ========== Initialization ========== */
function configureLayout(){
    // 3 hats spaced evenly
    const margin = 200;
    const usable = canvas.width - margin*2;
    const spacing = usable / 2;
    positions = [
        margin,
        margin + spacing,
        margin + spacing*2
    ];
    baseY = Math.round(canvas.height * 0.48);
    hats = positions.map(x => ({ x, y: baseY, width: HAT_W, height: HAT_H, lifting:0 }));
}
configureLayout();

/* ========== Game Flow ========== */
function resetRound(){
    // Ball always starts under center hat (hat 2, index 1)
    correctIndex = 1;
    hasBall = [false, true, false];
    
    hats.forEach((h,i)=>{
        h.x = positions[i];
        h.y = baseY;
        h.lifting = 0;
    });
    chosenIndex = -1;
    hoveredIndex = -1;
    state = 'showing';
    shuffleStart = 0;
    lastSwapTime = 0;
    nextSwapAfter = 0;
    revealStart = 0;
    messageBox.textContent = 'Watch the ball under hat 2...';
    messageBox.style.color = '#fff';
    restartBtn.classList.add('hidden');
    confettiPieces = [];
}

function startInitial(){
    if(state !== 'ready') return;
    resetRound();
    animate();
}

restartBtn.addEventListener('click', () => {
    resetRound();
});

function scheduleNextSwap(){
    nextSwapAfter = randInt(SWAP_INTERVAL_MIN, SWAP_INTERVAL_MAX);
}

/* ========== Swap Animation Logic ========== */
let activeSwap = null;

function startSwap(i,j){
    const duration = randInt(500, 800);
    const startTime = performance.now();
    const hi = hats[i];
    const hj = hats[j];
    const startXi = hi.x;
    const startXj = hj.x;
    const endXi = positions[j];
    const endXj = positions[i];
    const peak = 70; // arc height
    activeSwap = {
        i,j,startTime,duration,
        startXi,startXj,endXi,endXj,peak,
    };
}

function updateSwap(now){
    if(!activeSwap) return false;
    const {i,j,startTime,duration,startXi,startXj,endXi,endXj,peak} = activeSwap;
    const t = Math.min(1,(now - startTime)/duration);
    const eased = easeInOutQuad(t);
    const arcT = Math.sin(Math.PI * eased);
    hats[i].x = lerp(startXi, endXi, eased);
    hats[j].x = lerp(startXj, endXj, eased);
    hats[i].y = baseY - arcT*peak;
    hats[j].y = baseY - arcT*peak;
    if(t >= 1){
        hats[i].y = baseY;
        hats[j].y = baseY;
        // Swap positions array to track which hat is in which position
        [positions[i], positions[j]] = [positions[j], positions[i]];
        // Swap ball tracking
        [hasBall[i], hasBall[j]] = [hasBall[j], hasBall[i]];
        activeSwap = null;
        return true;
    }
    return false;
}

/* ========== Reveal (Lift Hat) ========== */
function startReveal(){
    revealStart = performance.now();
    state = 'revealing';
}

function updateReveal(now){
    const elapsed = now - revealStart;
    const t = Math.min(1, elapsed / LIFT_DURATION);
    const eased = easeOutCubic(t);
    const ballIdx = hasBall.indexOf(true);
    
    hats.forEach((h, idx)=>{
        if(state === 'revealing') {
            if(idx === chosenIndex) {
                h.lifting = eased;
            } else {
                h.lifting = 0;
            }
        } else if(state === 'result') {
            if(idx === ballIdx) {
                h.lifting = eased;
            } else {
                h.lifting = 0;
            }
        }
    });
    
    if(t >= 1){
        state = 'result';
        if(chosenIndex === ballIdx){
            spawnConfetti();
        }
    }
}

/* ========== Confetti ========== */
function spawnConfetti(){
    const pieces = 140;
    confettiPieces = new Array(pieces).fill(0).map(()=>({
        x: canvas.width/2 + randInt(-250,250),
        y: -20 - Math.random()*200,
        r: randInt(4,8),
        c: `hsl(${randInt(0,359)}, 80%, 50%)`,
        vy: 2 + Math.random()*3,
        vx: -2 + Math.random()*4,
        rot: Math.random()*Math.PI*2,
        vr: -0.2 + Math.random()*0.4,
        life: 0,
        maxLife: 3000 + Math.random()*1000
    }));
}

function updateConfetti(dt){
    confettiPieces.forEach(p=>{
        p.life += dt;
        p.x += p.vx;
        p.y += p.vy;
        p.rot += p.vr;
        p.vy += 0.02;
        if(p.y > canvas.height + 50) p.y = -50;
    });
    confettiPieces = confettiPieces.filter(p=>p.life < p.maxLife);
}

function drawConfetti(){
    confettiPieces.forEach(p=>{
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = p.c;
        ctx.fillRect(-p.r/2, -p.r/2, p.r, p.r);
        ctx.restore();
    });
}

/* ========== Rendering ========== */
function drawBackground(){
    const g = ctx.createRadialGradient(canvas.width/2, canvas.height*0.45, 100, canvas.width/2, canvas.height*0.6, canvas.height*0.9);
    g.addColorStop(0,'rgba(255,255,255,0.12)');
    g.addColorStop(0.4,'rgba(255,255,255,0.06)');
    g.addColorStop(1,'rgba(0,0,0,0.65)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.beginPath();
    ctx.ellipse(canvas.width/2, baseY + HAT_H + 40, 450, 60, 0, 0, Math.PI*2);
    const stageGrad = ctx.createRadialGradient(canvas.width/2, baseY + HAT_H + 40, 50, canvas.width/2, baseY + HAT_H + 40, 450);
    stageGrad.addColorStop(0,'rgba(255,255,255,0.15)');
    stageGrad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = stageGrad;
    ctx.fill();
}

function drawHat(h, idx, isHover, liftingOffset){
    const cx = h.x + h.width/2;
    const drawY = h.y - liftingOffset;
    const scale = isHover ? 1.08 : 1.0;
    
    // Shadow
    ctx.save();
    const shadowScale = 1 + h.lifting * 0.3;
    ctx.translate(cx, baseY + h.height - 10);
    ctx.scale(shadowScale, 1);
    ctx.beginPath();
    ctx.ellipse(0, 0, h.width*0.48, 18, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(cx, drawY + h.height/2);
    ctx.scale(scale, scale);
    
    // Draw hat (trapezoid shape)
    ctx.beginPath();
    const topWidth = h.width * 0.5;
    const bottomWidth = h.width * 0.9;
    const hatHeight = h.height;
    
    // Hat body (trapezoid)
    ctx.moveTo(-topWidth/2, -hatHeight/2);
    ctx.lineTo(topWidth/2, -hatHeight/2);
    ctx.lineTo(bottomWidth/2, hatHeight/2);
    ctx.lineTo(-bottomWidth/2, hatHeight/2);
    ctx.closePath();
    
    // Gradient for hat
    const hatGrad = ctx.createLinearGradient(0, -hatHeight/2, 0, hatHeight/2);
    hatGrad.addColorStop(0, '#d2691e');
    hatGrad.addColorStop(0.5, '#a0522d');
    hatGrad.addColorStop(1, '#8b4513');
    ctx.fillStyle = hatGrad;
    
    if(isHover){
        ctx.shadowColor = 'rgba(249, 178, 51, 0.8)';
        ctx.shadowBlur = 25;
    } else {
        ctx.shadowColor = 'rgba(0,0,0,0.75)';
        ctx.shadowBlur = 20;
        ctx.shadowOffsetY = 6;
    }
    ctx.fill();
    
    // Hat rim
    ctx.beginPath();
    ctx.ellipse(0, hatHeight/2, bottomWidth/2, 15, 0, 0, Math.PI*2);
    ctx.fillStyle = '#654321';
    ctx.fill();
    
    ctx.restore();
    
    // Draw hat number
    ctx.save();
    ctx.font = 'bold 32px Arial';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(0,0,0,0.8)';
    ctx.shadowBlur = 8;
    ctx.fillText((idx + 1).toString(), cx, drawY + h.height/2);
    ctx.restore();
}

function drawBall(cx, cy){
    // Draw ball as a gradient circle
    ctx.save();
    
    // Ball shadow
    ctx.beginPath();
    ctx.ellipse(cx, cy + BALL_RADIUS + 5, BALL_RADIUS * 0.8, BALL_RADIUS * 0.3, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fill();
    
    // Ball body
    const ballGrad = ctx.createRadialGradient(cx - BALL_RADIUS/3, cy - BALL_RADIUS/3, BALL_RADIUS * 0.2, cx, cy, BALL_RADIUS);
    ballGrad.addColorStop(0, '#ff6b6b');
    ballGrad.addColorStop(0.5, '#ee5a6f');
    ballGrad.addColorStop(1, '#c92a2a');
    
    ctx.beginPath();
    ctx.arc(cx, cy, BALL_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = ballGrad;
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 15;
    ctx.fill();
    
    // Highlight
    ctx.beginPath();
    ctx.arc(cx - BALL_RADIUS/4, cy - BALL_RADIUS/4, BALL_RADIUS/4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.shadowColor = 'transparent';
    ctx.fill();
    
    ctx.restore();
}

function drawHats(){
    hats.forEach((h, idx)=>{
        const liftingOffset = h.lifting * LIFT_REVEAL_HEIGHT;
        const isHover = (idx === hoveredIndex && state === 'guessing');
        const cx = h.x + h.width/2;
        
        // Draw ball if visible (showing, revealing, or result states)
        if((state === 'showing' || state === 'revealing' || state === 'result') && hasBall[idx]){
            const ballY = baseY + h.height - BALL_RADIUS - 5;
            drawBall(cx, ballY);
        }
        
        drawHat(h, idx, isHover, liftingOffset);
    });
}

/* ========== Main Animation Loop ========== */
let lastFrameTime = performance.now();
function animate(now = performance.now()){
    animationHandle = requestAnimationFrame(animate);
    const dt = now - lastFrameTime;
    lastFrameTime = now;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();

    switch(state){
        case 'showing':
            hats.forEach((h,i)=>{
                h.x = positions[i];
                h.y = baseY;
            });
            drawHats();
            if(!shuffleStart){
                shuffleStart = now;
                messageBox.textContent = 'Watch the ball under hat 2...';
                setTimeout(()=>{
                    state = 'shuffling';
                    shuffleStart = performance.now();
                    scheduleNextSwap();
                    messageBox.textContent = 'Shuffling for 20 seconds...';
                }, 2000);
            }
            break;
        case 'shuffling':
            if(activeSwap){
                const done = updateSwap(now);
                if(done){
                    lastSwapTime = now;
                    scheduleNextSwap();
                }
            } else if(now - shuffleStart < SHUFFLE_TIME){
                if(now - lastSwapTime >= nextSwapAfter){
                    const pairs = [[0,1],[1,2],[0,2]];
                    const [i,j] = pairs[randInt(0,pairs.length-1)];
                    startSwap(i,j);
                }
            } else {
                activeSwap = null;
                state = 'guessing';
                messageBox.textContent = 'Pick a hat (1, 2, or 3)!';
            }
            drawHats();
            break;
        case 'guessing':
            drawHats();
            break;
        case 'revealing':
            updateReveal(now);
            drawHats();
            break;
        case 'result':
            drawHats();
            updateConfetti(dt);
            drawConfetti();
            break;
    }
}

/* ========== Interaction ========== */
canvas.addEventListener('mousemove', (e)=>{
    if(state !== 'guessing'){ hoveredIndex = -1; return; }
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
    hoveredIndex = -1;
    for(let i=0;i<hats.length;i++){
        const h = hats[i];
        if(mx >= h.x && mx <= h.x + h.width && my >= h.y && my <= h.y + h.height){
            hoveredIndex = i;
            break;
        }
    }
});

canvas.addEventListener('mouseleave', ()=> hoveredIndex = -1);

canvas.addEventListener('click', ()=>{
    if(state === 'guessing' && hoveredIndex !== -1){
        chosenIndex = hoveredIndex;
        const ballIdx = hasBall.indexOf(true);
        const correct = (chosenIndex === ballIdx);
        if(correct){
            wins++;
            streak++;
            messageBox.textContent = 'ðŸŽ‰ Correct! You found the ball!';
            messageBox.style.color = 'var(--correct)';
        } else {
            losses++;
            streak = 0;
            messageBox.textContent = 'âŒ Wrong! The ball was under hat ' + (ballIdx + 1);
            messageBox.style.color = 'var(--wrong)';
        }
        rounds++;
        updateScoreboard();
        startReveal();
        restartBtn.classList.remove('hidden');
        setTimeout(()=>{
            if(state === 'result'){
                messageBox.textContent += ' - Click "Play Again"';
            }
        }, 1400);
    }
});

function updateScoreboard(){
    winsEl.textContent = wins;
    lossesEl.textContent = losses;
    streakEl.textContent = streak;
    roundsEl.textContent = rounds;
}

/* ========== Accessibility / Keyboard ========== */
document.addEventListener('keydown', (e)=>{
    if(state === 'guessing'){
        if(['1','2','3'].includes(e.key)){
            hoveredIndex = parseInt(e.key,10)-1;
        }
        if(e.key === 'Enter' && hoveredIndex !== -1){
            canvas.click();
        }
    } else if(state === 'result'){
        if(e.key.toLowerCase() === 'r'){
            resetRound();
        }
    }
});

/* ========== Start ========== */
messageBox.textContent = 'Ready to play!';
startInitial();

})(); // IIFE
</script>
</body>
</html>
